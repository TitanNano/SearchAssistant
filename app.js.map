{"version":3,"sources":["webpack:///webpack/bootstrap c0dfa4b8e38607ece321","webpack:////Users/Jovan/search-bot/node_modules/application-frame/util/make.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/Parser.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/Binding.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/Util.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/BindingRegistry.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/BindingApi.js","webpack:////Users/Jovan/search-bot/node_modules/application-frame/rendering/index.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/prototypes/ViewController.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/Bind.js","webpack:////Users/Jovan/search-bot/node_modules/application-frame/core/NetworkRequest.js","webpack:///./SelectedProperties.js","webpack:////Users/Jovan/search-bot/node_modules/application-frame/core/EventTarget.js","webpack:////Users/Jovan/search-bot/node_modules/application-frame/memory/index.js","webpack:///./views/AssistantChatView.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/main.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/Template.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/Mapping.js","webpack:////Users/Jovan/search-bot/node_modules/application-frame/rendering/CurrentFrameInterface.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/ScopePrototype.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/bindings/AnimationBinding.js","webpack:////Users/Jovan/search-bot/node_modules/application-frame/core/DataStorage.js","webpack:///./PropertyTypes.js","webpack:///./ArticleStore.js","webpack:///./modules/ArticlePropertyScraper/index.js","webpack:///./bootstrap.js","webpack:///./App.js","webpack:////Users/Jovan/search-bot/node_modules/application-frame/core/Application.js","webpack:////Users/Jovan/search-bot/node_modules/application-frame/core/async.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/Config.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/AutoBinding.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/ClassBinding.js","webpack:////Users/Jovan/search-bot/node_modules/application-frame/rendering/Frame.js","webpack:////Users/Jovan/search-bot/node_modules/application-frame/rendering/TaskList.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/EnabledBinding.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/StyleBinding.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/TwoWayBinding.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/TemplateLoader.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/ViewPort.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/IfBinding.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/ElementToScopeBinding.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/HtmlBinding.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/CloakBinding.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/bindings/AttributeBinding.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/bindings/TemplateRepeatBinding.js","webpack:////Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/bindings/EventBinding.js","webpack:///./modules/PropertyAssistant/index.js","webpack:///./modules/arrayContains.js","webpack:///./views/FiltersView.js","webpack:///./views/SearchBoxView.js","webpack:///./modules/ArrayAll.js","webpack:///./modules/SearchParser/index.js","webpack:///./ActionChain.js","webpack:///./views/SearchResultView.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AC7DA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,uBAAuB,eAAe;;AAEtC;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,MAAM;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA,mBAAmB,uBAAuB;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;AC/IA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC9HuB;AACG;AACL;;AAErB;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,yBAAyB;AACzB;AACA,wBAAwB;;AAExB;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;;AAEA;AACA,uCAAuC,EAAE,EAAE,UAAU,EAAE,EAAE;AACzD,aAAa;AACb;;;AAGA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL,sBAAsB,aAAa;AACnC;;AAEA;;;;;;;;;;;;;;;;;;;;;;ACrF8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB;AACA,YAAY,KAAK;AACjB;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC;AACA,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB;AACA,YAAY,SAAS;AACrB;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA,YAAY,KAAK;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,YAAY,KAAK;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wCAAwC;;AAExC;AACA;;AAEA;AACA,kDAAkD,EAAE,YAAY;;AAEhE;AACA;;AAEA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;;;;;;;;;;;ACrJA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT,yCAAyC,aAAa;AACtD;AACA;AACA,KAAK;;AAEL;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjD8B;AAC9B;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,eAAe,uBAAuB;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;ACtFA;AAAA;AACA;AACA;;AAE4B;AAC5B;AACA;;AAEA,WAAW,WAAW;AACtB;;AAEA,WAAW,WAAW;AACtB;;AAEA;;AAEA,+BAA+B,4BAA4B;;AAE3D,WAAW,QAAQ;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,EAAE;;AAEX;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,SAAS;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,eAAe,SAAS;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,EAAE;AAClB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,EAAE,EAAE;AACpB;AACA;AACA;AACA,KAAK;;AAEL;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,eAAe,SAAS;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,iCAAiC;AAC7C;AACA;AACQ;;;;;;;;;;;;;;ACnQR;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,2BAA2B,SAAS;AACpC;;AAEA,oGAAyD,wBAAwB;AACjF,KAAK;;AAEL;AACA,gBAAgB;AAChB,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpCA;AAAA;AACA;AACA;;AAEwB;AACK;AACiD;AACrD;AACJ;AACE;AACvB;AACA;AACA;AACA;AACA;AACuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,kCAAkC;AAC7C,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA,yBAAyB,IAAI,IAAI;AACjC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,+BAA+B,EAAE;AAC5E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,kCAAkC;AAC7C,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA,sCAAsC;AACtC;AACA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,kCAAkC;AAC7C,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB;AACA,YAAY;AACZ;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,KAAK;AAChB,WAAW,kCAAkC;AAC7C,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,kCAAkC;AAC9C,YAAY,KAAK;AACjB;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA,4FAA4F;;AAE5F;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,WAAW,kCAAkC;AAC7C;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2DAA2D,QAAQ;AACnE;AACA;AACA;;AAEA,+DAA+D,YAAY;AAC3E,iBAAiB;;AAEjB,aAAa;AACb;AACA;;AAEA;AACA;;AAEA,+DAA+D,QAAQ;AACvE;AACA,qBAAqB;AACrB,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA,0BAA0B,OAAO;AACjC;;AAEA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,6CAA6C,SAAS;AACtD;;AAEA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,WAAW,kCAAkC;AAC7C,WAAW,QAAQ;AACnB;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,uBAAuB,OAAO,cAAc,SAAS;AACrD;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;;;;;;;;;;;;;AC7iBA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;;AAEd;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA,aAAa,eAAe;AAC5B;AACA,uBAAuB,gCAAgC,KAAK;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,aAAa,eAAe;AAC5B;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,aAAa,eAAe;AAC5B;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,IAAI,GAAG,gBAAgB;AACjD,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;AClNA;;AAEA,OAAO,SAAS;;AAEhB;;AAEA,aAAa;;;AAGL;;;;;;;;;;;;;;ACTR;;AAEA;AACA;;AAEA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;;AAEA,oDAA2D;AAC3D;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AAAA;AAAA;;;;;;;;;;;;;;;;;;AC3DA;;AAE6B;AAC7B;AACuB;AACa;;AAEpC,OAAO,SAAS;;AAEhB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA,qDAAqD,qBAAqB,GAAG,kBAAkB;AAC/F;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA,oCAAoC,oBAAoB;AACxD,yCAAyC,YAAY;AACrD,KAAK;;AAEL;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AChHA;AAAA;AACA;AACA;AACA;AACA;AACA;AAC+C;AAC1B;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEmC;AACH;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC1DA;AAAA;AACA;AACA;;AAEe;AACI;AACiB;AACX;AACC;AACH;AACvB;;AAEA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC,YAAY,kCAAkC;AAC9C,YAAY,YAAY;AACxB,YAAY,KAAK;AACjB;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,2CAA2C,YAAY;AACvD;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,eAAe;AAC1B,WAAW,YAAY;AACvB,WAAW,eAAe;AAC1B;AACA,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;;AAEA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;;AAET,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA,gBAAgB;AAChB;AACA;;AAEA,wCAAwC,wBAAwB;AAChE;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC,YAAY,OAAO,UAAU;AAC7B,YAAY,YAAY;AACxB,YAAY,eAAe;AAC3B,YAAY,2CAA2C;AACvD;AACA,yCAAgD,qBAAqB,mCAAmC;AACxG;;AAEA;AACA,sCAAsC,+CAA+C;AACrF,4CAA4C,4CAA4C;AACxF;;AAEA;AACA;;AAEA,cAAc,gHAA2D;;AAEzE;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,YAAY;AACZ;AAAA;AAAA;;;;;;;;;;;;;ACjOA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA,kBAAkB,YAAY,GAAG,UAAU;AAC3C,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;;;;;;;;;;;;;ACzCA;AACA;AACA;;AAEA,iBAAiB,8BAA8B,KAAK;AACpD;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;;;;;;;;;;;;;;;ACrB0B;AACmB;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,SAAS;AACzB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;;;;;;;;;;;;;;;;ACnGA;AACA;AACwC;AACxC;AACuB;;AAEvB;AAAA;AAAA;;AAEA;AACA;AACA;AACA,WAAW;AACX,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,KAAK;AACpB,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB;AACA,gBAAgB;AAChB;AACA,WAAW,8BAA8B;AACzC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,cAAc,qBAAqB,cAAc;AAC5F;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wDAAwD,oBAAoB;AAC5E;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;;;;;;;;;;;;;AC/HA;;AAEA;AACA;AACA,oCAAoC,yCAAyC;AAC7E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,iCAAiC;AACrE;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,iCAAiC;AACzE,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;AC7EA;;AAEA,OAAO,SAAS;;AAEhB;;AAEA,yJAAiF,eAAe;;AAEhG;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;;;;;;;ACZA;AACA;AAC0B;AAC1B;AAC6B;;AAE7B,OAAO,SAAS;;AAEhB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AAAA;AAAA;;AAEA;AACA;;AAEA;AACA,6HAA4C,wFAAsC;;AAElF;AACA,KAAK;AACL;AAAA;AAAA;;AAEQ;;;;;;;;;;;;;ACtCR,qCAA4C,2BAA2B;AACvE;;AAEA,oDAAoD,8BAA8B;;AAElF;AACA;AAAA;AAAA;;AAEA,kCAAyC,2CAA2C;AACpF;;AAEA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAkB,UAAU,GAAG,UAAU;AACzC,iBAAiB,UAAU,GAAG,UAAU;AACxC;AACA;;;;;;;;;;;;;;ACpCA;AAAA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;;;;;;;;;;;;;;;;;ACZA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;;;;;;;;;;;;;ACjCA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gDAAgD,UAAU;AAC1D,KAAK;;AAEL;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,eAAe;AACf;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;;;;;;;;;;;;;AC1DA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACJA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;ACNe;AACf;AAC0B;AACH;;AAEvB;;AAEA;;AAEA,eAAe,iBAAiB;AAChC;;AAEA,eAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;;AAEb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;;;;;;ACrEe;AACW;AAC1B;AACuB;;AAEvB;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;;;;AC/DA;AACmB;;AAEnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,wKAA6D;AAC7D,qKAA0D;AAC1D,yKAA8D;;AAE9D;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACvBA;AAC4B;;AAE5B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,gBAAgB,8BAA8B;AAC9C;AACA;AACA,KAAK;;AAEL,eAAe,OAAO;AACtB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,mBAAmB;AACnC,gBAAgB;AAChB;AACA;AACA;AACA,6BAA6B,qBAAqB;;AAElD;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gCAAgC,qBAAqB;;AAErD;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA,KAAK;AACL;;AAEA;;;;;;;;;;;;;;;;;AC7Fe;AACW;AACL;AACrB;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,eAAe,kCAAkC;AACjD,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;;;;;ACjCA;AAAA;AACA;AACA;;AAEe;AAC0B;;AAEzC;AACuB;;AAEvB;AACA,WAAW,aAAa;AACxB,WAAW,eAAe;AAC1B,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,UAAU;AACV;AACA;AACA;;;;;;;;;;;;;;;;;;ACrDe;AACU;AACmB;AACvB;AACrB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;;;;ACvEe;AACf;AACA,UAAU,aAAa;;;AAGvB;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,oBAAoB;AAC/B;AACA,YAAY,oBAAoB;AAChC;AACA;AACA,6KAAiD;;AAEjD;AACA;;AAEA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC9CA;AAAA;AACA;AACA;;AAEsB;AACP;AACM;AACE;;AAEvB;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD,gBAAgB,YAAY;AAC5B;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,uDAAuD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,KAAK,oCAAoC;AACzD;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,WAAW;AAC1D,SAAS;;AAET;;AAEA,iGAAkD,WAAW,EAAE;AAC/D,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,4CAA4C;AAC5D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,uDAAuD,KAAK;AAC5D;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,6CAA6C;AAC7D;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;ACjPe;AACW;AAC1B;AACA;;AAEA;;AAEA,eAAe,OAAO;AACtB;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,KAAK;AACpB,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB;AACA,gBAAgB;AAChB;AACA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL,CAAC;;AAED;;AAEA;;;;;;;;;;;;;;;;AClEe;AAC6B;AAC5C;AACA;;AAEA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA,gBAAgB,KAAK;AACrB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA,gBAAgB;AAChB;AACA,qBAAqB,8BAA8B;AACnD;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA,mBAAmB,KAAK;AACxB;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL,CAAC;;AAED;;AAEA;;;;;;;;;;;;;;;;ACnDA;AAC0B;AACS;AACnC;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;;AAGA,WAAW,8BAA8B;AACzC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;ACzCA;AACqB;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;;;AAGA,WAAW,wBAAwB;AACnC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;;ACjDA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,iBAAiB,oCAAoC;AACrD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA,eAAe,SAAS;AACxB,eAAe,kBAAkB;AACjC;AACA;AACA;;;AAGA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA,eAAe,kBAAkB;AACjC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;AC1He;AACI;AACnB;;AAEA,OAAO,kBAAkB;;;AAGzB;;AAEA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA,WAAW,kCAAkC;AAC7C;;AAEA,wDAAwD,YAAY,QAAQ,KAAK;;AAEjF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,EAAE;AAClB,gBAAgB,eAAe;AAC/B,gBAAgB,OAAO;AACvB,gBAAgB,iBAAiB;AACjC,gBAAgB,KAAK;AACrB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,KAAK;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;;;;;;;;;;;;AC3RA;;AAEA;;AAEA;;AAEA,iBAAiB,wBAAwB;AACzC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;AC/C0B;AAC1B;;AAEA;AACA;AACA,gHAAuC,uBAAuB;;AAE9D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA,KAAK,IAAI;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AACA,4HAAmD,uBAAuB;;AAE1E;AACA,KAAK;AACL;AAAA;AAAA;;;;;;;;;;;;;ACjCA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACvBA;AAAA;AACA;AAC6B;;AAE7B,SAAS,SAAS;;AAElB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oCAAoC;;AAElE;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;AChCA;;AAEA;AACA;;AAE6B;AACgB;AAC7C;AACA;;AAEA,OAAO,SAAS;;AAEhB;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,kJAA0E,aAAa;AACvF,sJAA8E,aAAa;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa,IAAI;;AAEjB;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;;;;;;;;;;ACtEA;AACA;AACA;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;;AAEA,mCAA0C,0CAA0C,KAAK;;AAEzF;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,yCAAyC,yBAAyB,GAAG,wDAAwD;AAC7H,SAAS;AACT,wCAAwC,yBAAyB;AACjE;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,KAAK,IAAI;;AAET;AACA;AAAA;AAAA;;;;;;;;;;;;;ACrDA,OAAO,SAAS;;AAEhB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,6BAA6B,cAAc;AAC3C,KAAK;;AAEL;AACA;AACA,2BAA2B,gBAAgB,wBAAwB,aAAa;AAChF;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;AC/DA;AAAA;AACA;AACuB;;AAEvB,SAAS,SAAS;;AAElB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 24);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c0dfa4b8e38607ece321","/**\n * The make module consits of Make, getPrototypeOf and mixin.\n * See the documentation for each method to see what is does.\n * This module is part of the ApplicationFrame.\n * @module Make\n * @author Jovan Gerodetti\n * @copyright Jovan Gerodetti\n * @version 1.0\n */\n\n\n/**\n * Internal function to apply one objects propteries to a target object.\n *\n * @param {Object} target\n * @param {Object} source\n * @inner\n */\nvar apply = function (target, source) {\n    Object.keys(source).forEach(function(key){\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n\n    return target;\n};\n\n/**\n * Creates a new object with the given prototype.\n * If two arguments are passed in, the properties of the first object will be\n * applied to the new object.\n *\n * @param {Object} object\n * @param {Object} prototype\n * @return {function}\n */\nexport var Make = function(object, prototype) {\n    if(arguments.length < 2){\n        prototype = object;\n        object = null;\n    }\n\n    if (object === null) {\n        object = Object.create(prototype);\n    } else {\n        object = apply(Object.create(prototype), object);\n    }\n\n    var m = function(...args){\n        var make = object.make || object._make || function(){};\n\n        make.apply(object, args);\n\n        return object;\n    };\n\n    m.get = function(){ return object; };\n\n    return m;\n};\n\n/**\n * This method checks if the given prototype is in the prototype chain of\n * the given target object.\n *\n * @param {Object} object\n * @param {Object} prototype\n * @return {boolean}\n */\nexport var hasPrototype = function(object, prototype){\n    var p = Object.getPrototypeOf(object);\n\n    while(p !== null && p !== undefined){\n        if(typeof prototype == 'function')\n            prototype = prototype.prototype;\n\n        if(p == prototype)\n            return true;\n        else\n            p = Object.getPrototypeOf(p);\n    }\n\n    return false;\n};\n\n/**\n * Creates a new prototype mixing all the given prototypes. Incase two or more\n * prototypes contain the same propterty, the new prototype will return\n * the propterty of the first prototype in the list which contains it.\n *\n * @param {...Object} prototypes - the porotype object to combine\n * @return {Proxy} - the resulting proxy object\n */\nexport var Mixin = function(...prototypes){\n\n    return new Proxy(prototypes, MixinTrap);\n\n};\n\n/**\n * Internal function to find a proptery in a list of prototypes.\n *\n * @param {Object[]} prototypes\n * @param {string} key\n * @return {Object}\n */\nvar findProperty = function(prototypes, key) {\n    for (var i = 0; i < prototypes.length; i++) {\n        var item = prototypes[i];\n\n        if (item && item[key]) {\n            return item;\n        }\n    }\n\n    return undefined;\n};\n\n/**\n * Traps to create a mixin.\n */\nvar MixinTrap = {\n\n    'get' : function(prototypes, key) {\n        var object = findProperty(prototypes, key);\n\n        if (object && typeof object[key] === 'function') {\n            return object[key].bind(object);\n        }\n\n        return (object ? object[key] : null);\n    },\n\n    'set' : function(prototypes, key, value) {\n        var object = findProperty(prototypes, key);\n\n        if (object) {\n            object[key] = value;\n        } else {\n            prototypes[0][key] = value;\n        }\n\n        return true;\n    }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/application-frame/util/make.js\n// module id = 0\n// module chunks = 0","/**\n * @module DataBinding/Parser\n */\n\n/**\n * Parses an object expression\n *\n * @param {string} source - the string to parse.\n * @return {Object} the parsed result.\n */\nexport let ObjectParser = function(source){\n    let target = null;\n    let key = false;\n    let keyBuffer = '';\n    let valueBuffer = '';\n    let run = true;\n\n    source.split('').forEach((char) => {\n        if (run) {\n            if (char === '{') {\n                target = {};\n                key = true;\n            } else if(char === ':') {\n                key = false;\n            } else if(char === ',') {\n                target[keyBuffer.trim()] = valueBuffer.trim();\n                keyBuffer = valueBuffer = '';\n                key = true;\n            } else if(char === '}') {\n                target[keyBuffer.trim()] = valueBuffer.trim();\n                run = false;\n            } else if(key) {\n                keyBuffer += char;\n            } else if(!key) {\n                valueBuffer += char;\n            }\n        }\n    });\n\n    return target;\n};\n\n/**\n * Parses a given expression in the context of the given scope.\n *\n * @param {string} expression - the expression to parse.\n * @param {ScopePrototype} scope - the scope on which the expression should be parsed.\n * @return {*} the result value.\n */\nexport let parseExpression = function(expression, ...contexts) {\n    expression = expression.trim();\n    let chain = expression.match(/[\\w\\$]+(?:\\([^)]*\\))*/g) || [];\n    let scope = null;\n    let functionTest = /\\(([^)]*)\\)/;\n\n    if (!isNaN(expression)) {\n        return parseFloat(expression);\n    }\n\n    if (chain.length === 0) {\n        return undefined;\n    }\n\n    for (let i = 0; i < contexts.length; i++) {\n        scope = contexts[i];\n\n        chain.forEach((item) => {\n            let pos = item.search(functionTest);\n\n            if (scope) {\n                if (pos > 0) {\n                    let args = item.match(functionTest)[1].split(',').map(item => item.trim());\n                    let scopeChild = scope[item.substring(0, pos)];\n\n                    if (scopeChild) {\n                        args = args.map(arg => parseExpression(arg, ...contexts));\n                        scope = scopeChild.apply(scope, args);\n                    } else {\n                        scope = null;\n                    }\n                } else {\n                    if (typeof scope[item] === 'function') {\n                        scope = scope[item].bind(scope);\n                    } else {\n                        scope = scope[item];\n                    }\n                }\n            }\n        });\n\n        if (scope !== null && scope !== undefined) {\n            break;\n        }\n    }\n\n    return (scope !== null && typeof scope !== 'undefined') ? scope : '';\n};\n\nexport const parseAttributeName = function(attributeName) {\n    const regExp = /^([a-zA-Z0-9\\-]+)(?:$|\\((.*)\\)$)/;\n    const result = attributeName.match(regExp) || [];\n\n    result.shift();\n\n    return result;\n};\n\n/**\n * Assings an value to an expression in an given scope\n *\n * @param {string} expression the expression on whith the value should be assigned\n * @param {ScopePrototype} scope the scope to operate on\n * @param {string} value the value to assign\n *\n * @return {void}\n */\nexport let assignExpression = function(expression, scope, value){\n    let chain = expression.split('.');\n\n    chain.forEach((property, index) => {\n        if (chain.length -1 !== index) {\n            scope = scope[property];\n        } else {\n            scope[property] = value;\n        }\n    });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/Parser.js\n// module id = 1\n// module chunks = 0","import { hasPrototype } from '../af/util/make';\nimport { parseExpression } from './Parser.js';\nimport { polyInvoke } from './Util.js';\n\n/** @lends module:DataBinding.Binding.prototype */\nlet Binding = {\n\n    /**\n     * @type {string[]}\n     */\n    properties : null,\n\n    /**\n     * @type {string}\n     */\n    originalNodeValue : '',\n\n    /**\n     * @type {Node}\n     */\n    node : null,\n\n    /**\n     * @type {Node}\n     */\n    parentNode : null,\n\n    /**\n     * @type {Boolean}\n     */\n    singleExpression : false,\n\n    /**\n     * The basic prototype for bindings. Any binding should inherit form this prototype.\n     *\n     * @constructs\n     * @return {void}\n     */\n    _make : function() {\n        this.properties = [];\n    },\n\n    /**\n     * updates a binding. The model will be checked for changes\n     * and new data will be applied to the binding target.\n     *\n     * @param  {module:DataBinding.ScopePrototype} scope the scope on which\n     *                                             this binding should operate.\n     *\n     * @return {void}\n     */\n    update : function(scope){\n        let text = this.originalNodeValue;\n        let localNode = { element: this.parentNode };\n        let values = this.properties.map(key => {\n            let item = { name : key, value : parseExpression(key, localNode, scope) };\n\n            return item;\n        });\n\n        if (this.singleExpression) {\n            text = parseExpression(text, localNode, scope);\n        } else {\n            text = text.toString().trim().split(/\\s+/).join(' ');\n\n            values.forEach(pair => {\n                text = text.replace(`\\{\\{${pair.name}\\}\\}`, pair.value);\n            });\n        }\n\n\n        if (hasPrototype(this.node, window.Attr)) {\n            if (this.parentNode.getAttribute(this.node.name) !== text) {\n                polyInvoke(this.parentNode).setAttribute(this.node.name, text);\n            }\n        } else {\n            if (this.node.textContent !== text) {\n                this.node.textContent = text;\n            }\n        }\n    },\n\n    test: function() { return true; }\n};\n\nexport default Binding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/Binding.js\n// module id = 2\n// module chunks = 0","import { Mixin, hasPrototype } from '../af/util/make.js';\n\n/**\n * selects a dom node by the given query.\n *\n * @function\n * @deprecated don't use this anymore, polyMask is deprecated.\n *\n * @param {string} query the query selector to search for on the DOM\n * @param {Node} [context] the node to start the searching on\n *\n * @return {Node} the first node that matches the selector\n */\nexport let selectElement = function(query, context){\n    let node = null;\n\n    if (context) {\n        node = context.querySelector(query);\n    } else {\n        node = document.querySelector(query);\n    }\n\n    node = polyMask(node);\n\n    return node;\n};\n\n/**\n * @function\n * @deprecated don't use anymore. Use {@link document.querySelectorAll}\n *\n * @param {string} query the query to look for\n * @param {Node} context the node to start the searching on\n *\n * @return {NodeList} the node list with all matching nodes\n */\nexport let selectAllElements = function(query, context) {\n    let nodeList = null;\n\n    if (context) {\n        nodeList = context.querySelectorAll(query);\n    } else {\n        nodeList = document.querySelectorAll(query);\n    }\n\n    if (window.Polymer) {\n        nodeList = [].map.apply(nodeList, [polyMask]);\n    }\n\n    return nodeList;\n};\n\n/**\n * attempts to extract the original node from an polymer node\n *\n * @function\n * @deprecated there is no need to use this function anymore\n *\n * @param {Node} node the node to unwrap\n *\n * @return {Node} a mixin exposing the original node\n */\nexport let unwrapPolymerNode = function(node) {\n    if (!hasPrototype(node, Node)) {\n        return Mixin(node, node.node);\n    }\n\n    return node;\n};\n\n/**\n * creates a mixin of the node and a wrapped version from Polymer\n *\n * @function\n * @deprecated this method shouldn't be used anymore. Use polyInvoke\n *\n * @param {Node} node the dom node to mask\n *\n * @return {Node} returns the masked node\n */\nexport let polyMask = function(node){\n    let polyNode = {};\n\n    let additions = {\n        get bare (){\n            return node;\n        }\n    };\n\n    if (window.Polymer) {\n        polyNode = window.Polymer.dom(node);\n    }\n\n    return Mixin(polyNode, node, additions);\n};\n\n/**\n * Tries to call Polymers dom() function if available, to keep them in the loop.\n *\n * @param {Node} node the node we want to take care of.\n * @return {Node} the dom node, maybe wrapped.\n */\nexport let polyInvoke = function(node) {\n\n    if (window.Polymer) {\n        node = window.Polymer.dom(node);\n    }\n\n    return node;\n};\n\n/**\n * attempts to find a parent node with a particular node name\n *\n * @function\n *\n * @param {Node} node the base node\n * @param {string} parentName the node name to search for\n *\n * @return {Node} the node we where searching for\n */\nexport let getPolyParent = function(node, parentName){\n    while (node && node.localName !== parentName) {\n        node = node.parentNode;\n    }\n\n    return node;\n};\n\nexport let sanitizeText = function(rawText) {\n    let text = rawText.replace(/\\&nbsp\\;/g, '\\u00a0').replace(/<br>/, '\\n');\n\n    // html escape\n    text = document.createTextNode(text).textContent;\n\n    //fix legal HTML\n    text = text.replace(/\\n/g, '<br>').replace(/ {2}/g, ' &nbsp;');\n\n    return text;\n};\n\n/**\n * checks if a node is currenty visible on the viewport\n *\n * @param  {Node} node - the node to check\n * @return {boolean} - the visibility status of the node\n */\nexport let nodeIsVisible = function(node) {\n    return node.offsetHeight === 0 && node.offsetWidth === 0;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/Util.js\n// module id = 3\n// module chunks = 0","/**\n * @module DataBinding/BindingRegistry\n */\n\n/**\n * Registry of all bindings.\n *\n * @type {Object}\n */\nlet registry = {};\n\n\n/**\n * Public Singleton Interface for the binding registry.\n *\n * @class BindingRegistry\n */\n/** @lends module:DataBinding/BindingRegistry~BindingRegistry.prototype */\nlet BindingRegistry = {\n\n    /**\n     * @param {Binding} binding - new binding type\n     * @return {boolean} - success status\n     */\n    register : function(binding) {\n        if (!registry[binding.name]) {\n            registry[binding.name] = binding;\n            return true;\n\n        } else {\n            console.warn(`Binding type ${binding.name} already exists!`);\n            return false;\n        }\n    },\n\n    /**\n     * @param {string} name - binding name\n     * @return {Binding} - the binding for the given name\n     */\n    get: function(name) {\n        return registry[name];\n    }\n};\n\n/**\n * @member BindingRegistry\n * @static\n * @type module:DataBinding/BindingRegistry~BindingRegistry\n */\nexport default BindingRegistry;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/BindingRegistry.js\n// module id = 4\n// module chunks = 0","import { scheduleScopeUpdate } from './Bind';\nimport Binding from './Binding';\nimport BindingRegistry from './BindingRegistry';\nimport * as Parser from './Parser';\n\nlet currentScopeInfo = null;\n\nconst instanceMap = new WeakMap();\n\nconst BindingApiPrototype = {\n\n    _binding: null,\n\n    _scopeInfo: null,\n\n    registerBinding(binding) {\n        return BindingRegistry.register(binding);\n    },\n\n    attachBinding(bindingInstance) {\n        currentScopeInfo.bindings.push(bindingInstance);\n    },\n\n    parser: Parser,\n\n    Binding,\n\n    scheduleScopeUpdate(callback) {\n\n        const { _binding: identifier } = this;\n\n        if (!this._scopeInfo) {\n            console.error('[DataBinding API]', '\"scheduleScopeUpdate\" has to be called on an api instance! No scope context present!');\n            return;\n        }\n\n        if (!identifier || typeof identifier.update !== 'function' || typeof identifier.test !== 'function') {\n            console.log('[DataBinding API]',\n                'unable to schedule scope update! identifier does not match the Binidng trait!');\n\n            return;\n        }\n\n        if (!this.updateScheduled) {\n            scheduleScopeUpdate(this._scopeInfo, (scope) => {\n                this.scheduledScopeUpdates.forEach(callback => callback(scope));\n                this.scheduledScopeUpdates.length = 0;\n                this.updateScheduled = false;\n            });\n\n            this.updateScheduled = true;\n        }\n\n        this.scheduledScopeUpdates.set(identifier, callback);\n    }\n};\n\nconst BindingApi = function(binding) {\n    if (!binding) {\n        return BindingApiPrototype;\n    }\n\n    if (instanceMap.has(binding)) {\n        return instanceMap.get(binding);\n    } else if (currentScopeInfo) {\n        const instance = {\n            _binding: binding,\n            _scopeInfo: currentScopeInfo,\n            scheduledScopeUpdates: new Map(),\n            updateScheduled: false,\n\n            __proto__: BindingApiPrototype,\n        };\n\n        instanceMap.set(binding, instance);\n        return instance;\n    }\n\n    console.error('No scope context present! Unable to return api instance!');\n    return null;\n};\n\nexport default BindingApi;\n\nexport const setScopeInfo = function(newScopeInfo) {\n    currentScopeInfo = newScopeInfo;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/BindingApi.js\n// module id = 5\n// module chunks = 0","/**\n * @module RenderEngine\n */\n\nimport { allocate, release } from '../memory';\nimport Frame from './Frame';\nimport CurrentFrameInterface from './CurrentFrameInterface';\n\n/** @type {Function[]} */\nlet preRenderHooks = [];\n\n/** @type {Function[]} */\nlet postRenderHooks = [];\n\nconst frameBuffer = [];\n\nframeBuffer.last = function() { return this[this.length-1]; };\n\n/** @type {boolean} */\nlet active = false;\n\nconst getNow = function() {\n    return window.performance ? window.performance.now() : Date.now();\n};\n\nconst renderConfig = {\n    lightray: false,\n};\n\n/**\n * performs all render tasks from one frame. This is one render cycle.\n *\n * @param {number} startTime - the time the render cycle started\n *\n * @return {void}\n */\nlet renderCycle = function(startTime) {\n    active = false;\n\n    // run all post render hooks after a frame has been painted. So this happens\n    // at the beginning of the next cycle.\n    postRenderHooks.forEach(hook => {\n        hook();\n    });\n\n    frameBuffer[0].postRenderTasks.filter(task => {\n        task();\n    });\n\n    // init render cycle START\n    const frame = frameBuffer[1];\n\n    // migrate remaining tasks to this Frame\n    frameBuffer[0].preRenderTasks.getAll().forEach((task) => {\n        frame.preRenderTasks.unshift(task.work, task.id);\n    });\n\n    frameBuffer[0].renderTasks.getAll().forEach((task) => {\n        frame.renderTasks.unshift(task.work, task.id);\n    });\n\n    frameBuffer[0].postRenderTasks.getAll().forEach((task) => {\n        frame.postRenderTasks.unshift(task.work, task.id);\n    });\n\n    const oldFrame = frameBuffer.shift();\n    release(oldFrame);\n\n    if (frameBuffer.length < 2) {\n        frameBuffer.push(allocate('Frame', Frame));\n//        frameBuffer.push(Object.create(Frame).constructor());\n    }\n\n    const currentFrameInterface = allocate('CurrentFrameInterface', CurrentFrameInterface);\n\n    currentFrameInterface._startTime = startTime;\n    currentFrameInterface._maxFrameDuration = renderConfig.lightray ? (1000 / 60) : (1000 / 30);\n\n     /*Object.create(CurrentFrameInterface)\n        .constructor({\n            startTime: startTime,\n            maxFrameDuration: renderConfig.lightray ? (1000 / 60) : (1000 / 30),\n        });*/\n\n    // init render cycle END\n\n    // run the pre render hooks before we start to do render stuff.\n    preRenderHooks.forEach(hook => hook(currentFrameInterface));\n\n    // run pre render tasks\n    frame.preRenderTasks.run(currentFrameInterface);\n\n    //run all render tasks.\n    frame.renderTasks.run(currentFrameInterface);\n    //create performance data\n    const cycleDuration = getNow() - startTime;\n    const frameRate = 1000 / cycleDuration;\n\n    RenderEngine.performance.lastFrameDuration = cycleDuration;\n    RenderEngine.performance.fps = frameRate;\n    RenderEngine.performance.renderedFrames += 1;\n\n    // done wait for next frame\n    scheduleNextFrame();\n};\n\n/**\n * Schedules a new render cycle in the browsers rendering engine.\n * The cycle is performed as soon as the browser is ready to render a new frame.\n *\n * @return {void}\n */\nlet scheduleNextFrame = function() {\n    if (!active && frameBuffer.length > 0) {\n\n        if (frameBuffer.length === 2 && frameBuffer[0].emtpy && frameBuffer[1].empty) {\n            return;\n        }\n\n        window.requestAnimationFrame(renderCycle);\n\n        active = true;\n    }\n};\n\n\n/**\n * RenderEngine Singleton\n *\n * @namespace\n */\nconst RenderEngine = {\n\n    _currentFrame: 1,\n\n    get lightray() {\n        return renderConfig.lightray;\n    },\n\n    set lightray(value) {\n        return renderConfig.lightray = value;\n    },\n\n    performance: {\n        fps: 0,\n        lastFrameDuration: 0,\n        renderedFrames: 0,\n    },\n\n    /**\n     * @param {Function} f a hook function to execute before each render cycle\n     * @return {Function} returns the function which has been passed in\n     */\n    addPreRenderHook: function(f) {\n        preRenderHooks.push(f);\n        scheduleNextFrame();\n\n        return f;\n    },\n\n    /**\n     * @param {Function} f - a hook function to execute after each render cycle\n     * @return {Function} returns the function which has been passed in.\n     */\n    addPostRenderHook: function(f) {\n        postRenderHooks.push(f);\n        scheduleNextFrame();\n\n        return f;\n    },\n\n    /**\n     * Removes a previously added pre render hook\n     *\n     * @param  {Function} f - the function which was previously added\n     * @return {*} - see Array.prototype.splice\n     */\n    removePreRenderHook: function(f) {\n        return preRenderHooks.splice(preRenderHooks.indexOf(f), 1);\n    },\n\n    /**\n     * Removes a previously added post render hook\n     *\n     * @param  {Function} f - the function which was previously added\n     * @return {*} {@link Array.prototype.splice}\n     */\n    removePostRenderHook: function(f) {\n        return postRenderHooks.splice(postRenderHooks.indexOf(f), 1);\n    },\n\n    /**\n     * @param {Function} f - the task to preform in the next render cycle.\n     * @param {string} [id] optional task id\n     * @return {Function} the function which has been passed in.\n     */\n    schedulePreRenderTask: function(f, id) {\n        frameBuffer[this._currentFrame].preRenderTasks.push(f, id);\n        scheduleNextFrame();\n\n        return f;\n    },\n\n    /**\n     * @param {Function} f - the task to preform in the next render cycle.\n     * @param {string} [id] optional task id\n     * @return {Function} the function which has been passed in.\n     */\n    scheduleRenderTask: function(f, id) {\n        frameBuffer[this._currentFrame].renderTasks.push(f, id);\n        scheduleNextFrame();\n\n        return f;\n    },\n\n    /**\n     * @param {Function} f - the task to preform after the next render cycle.\n     * @return {Function} the function which has been passed in.\n     */\n    schedulePostRenderTask: function(f) {\n        frameBuffer[this._currentFrame].postRenderTasks.push(f);\n        scheduleNextFrame();\n\n        return f;\n    },\n\n    /**\n     * Forces the engine to render a new frame even if there are no tasks\n     *\n     * @return {void}\n     */\n    renderFrame: function() {\n        if(!active) {\n            scheduleNextFrame();\n        }\n    },\n\n    skipFrame() {\n        const frameIndex = this._currentFrame + 1;\n\n        if (!frameBuffer[frameIndex]) {\n            frameBuffer.push(allocate('Frame', Frame));\n//            frameBuffer.push(Object.create(Frame).constructor());\n        }\n\n        return { _currentFrame: frameIndex, __proto__: RenderEngine };\n    }\n};\n\n// init zero frame\nframeBuffer.push(allocate('Frame', Frame));\nframeBuffer.push(allocate('Frame', Frame));\n//frameBuffer.push(Object.create(Frame).constructor());\n//frameBuffer.push(Object.create(Frame).constructor());\n\n/**\n * @member {module:RenderEngine~RenderEngine} RenderEngine\n * @static\n */\nexport { RenderEngine };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/application-frame/rendering/index.js\n// module id = 6\n// module chunks = 0","import DataBinding from '../main';\n\nconst ViewController = {\n    template: '',\n\n    scope: null,\n\n    constructor() {\n        let template = this.template;\n\n        if (typeof template === 'string' && template.indexOf('#') !== 0) {\n            template = `#${template}`;\n        }\n\n        this.scope = DataBinding.createTemplateInstance({ template, scope: this }).scope;\n    },\n\n    useInAutoBinding() {\n        return { view: Object.create(this) };\n    },\n\n    isActive: false,\n\n    isRoutedPeristently: false,\n\n    onRouteEnter() {\n        this.isActive = true;\n        this.scope.__apply__();\n    },\n\n    onRouteLeave() {\n        this.isActive = false;\n        this.scope.__apply__();\n    }\n};\n\nexport default ViewController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/prototypes/ViewController.js\n// module id = 7\n// module chunks = 0","/**\n * @module DataBinding/Bind\n */\n\nimport { CurrentConfig } from './Config';\nimport { Make, hasPrototype } from '../af/util/make.js';\nimport { ObjectParser, parseExpression, assignExpression, parseAttributeName } from './Parser.js';\nimport { attributeNames } from './Mapping.js';\nimport { polyInvoke } from './Util.js';\nimport { setScopeInfo } from './BindingApi';\nimport AutoBinding from './AutoBinding.js';\nimport Binding from './Binding.js';\nimport BindingRegistry from './BindingRegistry.js';\nimport ClassBinding from './ClassBinding.js';\nimport EnabledBinding from './EnabledBinding.js';\nimport { RenderEngine } from '../af/rendering';\nimport ScopePrototype from './ScopePrototype.js';\nimport StyleBinding from './StyleBinding';\nimport TwoWayBinding from './TwoWayBinding.js';\n\n/**\n * Contains all scope, scopeInfo pairs.\n *\n * @type {WeakMap}\n */\nlet scopeList = new Map();\n\n/**\n * @type {ScopePrototype[]}\n */\nlet scopeIndex = [];\n\n/**\n * @type {Array[]}\n */\nexport let watcherList = new Map();\n\n/**\n * @type {Object}\n */\nlet expressionTracking = {};\n\n/**\n * applies the binding to the node for the given scope.\n *\n * @function\n * @param {Node|string} node - the node which should be bound\n * @param {Object} scope - the scope which should be bound to\n * @param {boolean} isolated - indicates if this scope should be recycled isolated\n * @return {module:DataBinding~ScopePrototype} the scope this node is bound to\n */\nexport let bindNode = function(node, scope, isolated) {\n    scope = hasPrototype(scope, ScopePrototype) ? scope : Make(scope, ScopePrototype)();\n    node = hasPrototype(node, Node) ? node : document.querySelector(node);\n\n    scopeList.set(scope, {\n        node : node,\n        bindings : [],\n        scheduledTasks: [],\n    });\n\n    scopeIndex.push(scope);\n\n    checkNode(node, scope);\n    setScopeInfo(null);\n    recycle(isolated ? scope : false);\n\n    return scope;\n};\n\n/**\n * Travels through a node and it's children searching for binding expressions\n *\n * @param {Node} node - the node to check\n * @param {module:DataBinding.ScopePrototype} scope - the scope this node should be bound to\n * @param {Node} parentNode - the parent of the provided node\n * @return {void}\n */\nlet checkNode = function(node, scope, parentNode) {\n    const dataRegex = /{{[^{}]*}}/g;\n    const scopeInfo = scopeList.get(scope);\n\n    setScopeInfo(scopeInfo);\n\n    if (node.nodeName == '#text' || isAttribute(node)) {\n        const [attributeName, attributeParameter] = parseAttributeName(node.nodeName);\n        let text = node.value || polyInvoke(node).textContent,\n            variables = text.match(dataRegex),\n            visibilityBinding = (node.name === attributeNames.get('visible')),\n            transparencyBinding = (node.name === attributeNames.get('transparent')),\n            enabledAttribute = node.name === attributeNames.get('enabled'),\n            classes = (node.name === attributeNames.get('classes')),\n            modelBinding = node.name === attributeNames.get('model'),\n            autoBinding = node.name === 'bind',\n            twoWay = (node.name === attributeNames.get('value') || modelBinding),\n            styleBinding = (node.name === 'bind-style');\n\n        let singleBinding = visibilityBinding || transparencyBinding;\n\n        if (twoWay) {\n            bindTwoWay(text, scope, scopeInfo, node, parentNode, modelBinding);\n        } else if (classes) {\n            bindClasses(text, node, scopeInfo, parentNode);\n        } else if (enabledAttribute) {\n            bindEnabled(text, scopeInfo, parentNode);\n        } else if (autoBinding) {\n            bindAuto(text, scopeInfo, parentNode);\n        } else if (styleBinding) {\n            bindStyle(text, scopeInfo, scope, parentNode);\n        } else if (BindingRegistry.get(attributeName) && BindingRegistry.get(attributeName).test()) {\n            Make(BindingRegistry.get(attributeName))({\n                text: text,\n                variables: variables,\n                scopeInfo: scopeInfo,\n                node: parentNode,\n                attribute: node,\n                parameter: attributeParameter,\n                parentNode: parentNode,\n            });\n        } else if (variables || singleBinding) {\n            bindSimple(text, node, variables, scopeInfo, singleBinding, parentNode);\n        }\n\n    } else {\n        if (node.attributes) {\n            node.attributes.forEach((child) => checkNode(child, scope, node));\n\n            let events = node.getAttribute(attributeNames.get('events'));\n\n            if (events !== null) {\n                bindEvents(events, node, scope);\n\n                polyInvoke(node).removeAttribute(attributeNames.get('events'));\n            }\n        }\n\n        node.childNodes.forEach((node) => { return checkNode(node, scope); });\n    }\n};\n\nconst isAttribute = function(node) {\n    return Object.getPrototypeOf(node) === Attr.prototype;\n};\n\n/**\n * creates a two way binding\n *\n * @param {string} text - the attribute text\n * @param {module:DataBinding.ScopePrototype} scope - the scope for this binding\n * @param {Object} scopeInfo - the scopeInfo for this binding\n * @param {Node} node - the attribute node\n * @param {Node} parentNode - the actual node\n * @param {boolean} indirect - indicates if this binding is indirect\n * @return {void}\n */\nlet bindTwoWay = function(text, scope, scopeInfo, node, parentNode, indirect){\n    let expression = text.replace(/[{}]/g, '');\n    let [eventType, viewBinding, eventBinding, preventDefault] =\n        (parentNode.getAttribute(attributeNames.get('modelEvent')) || '').split(':');\n    let debounce = null;\n\n    /** @type {TwoWayBinding} */\n    let binding = Make({\n        properties : [expression],\n        originalNodeValue : text,\n//      disable this so the value gets applied to the DOM the first time\n//        currentValue : value,\n        node : node,\n        parentNode : parentNode,\n        indirect : indirect,\n        viewBinding : viewBinding,\n    }, TwoWayBinding).get();\n\n    scopeInfo.bindings.push(binding);\n\n    if (node.name === attributeNames.get('model')) {\n        parentNode.addEventListener(eventType, event => {\n            if (preventDefault === 'true') {\n                event.preventDefault();\n            }\n\n            if (debounce) {\n                clearTimeout(debounce);\n            }\n\n            debounce = setTimeout(() => {\n                // read current value in view\n                let value = parseExpression(eventBinding, event);\n\n                compareTwoWay(value, scope, binding);\n            }, 300);\n        });\n    } else if(node.name === attributeNames.get('value')) {\n        parentNode.addEventListener('keyup', e => {\n            e.preventDefault();\n\n            if (debounce) {\n                clearTimeout(debounce);\n            }\n\n            debounce = setTimeout(() => {\n                compareTwoWay(getElementValue(e.target), scope, binding);\n            }, 200);\n        });\n    }\n};\n\n/**\n * Compares for changes in the UI in a two way binding\n *\n * @param {string} newValue - the new value to compare\n * @param {module:DataBinding.ScopePrototype} scope - the scope of the comparison\n * @param {TwoWayBinding} binding - the binding to compare\n * @return {void}\n */\nlet compareTwoWay = function(newValue, scope, binding){\n    if (binding.currentValue !== newValue) {\n        assignExpression(binding.properties[0], scope, newValue);\n        binding.currentValue = newValue;\n\n        console.log('update from view:', scope);\n\n        recycle();\n    }\n};\n\n/**\n * creates a simple binding\n *\n * @param {string} text the initial text of the node\n * @param {Node} node the text or attribute node of the binding\n * @param {string[]} variables list of expressions\n * @param {Object} scopeInfo meta data of the current scope\n * @param {boolean} singleExpression - indicates if text contains only one expression\n * @param {Node} parentNode the element that contains the text node or attribute\n *\n * @return {void}\n */\nlet bindSimple = function(text, node, variables, scopeInfo, singleExpression, parentNode){\n    /** @type {Binding} */\n    let binding = Make({\n        originalNodeValue : text,\n        node : node,\n        parentNode : parentNode,\n        singleExpression : singleExpression,\n        properties : variables ? variables.map(item => item.replace(/[{}]/g, '')) : []\n    }, Binding).get();\n\n    // clear value so interpolation expression doesn't apear on screen.\n    if (hasPrototype(node, window.Attr)) {\n        parentNode.setAttribute(node.name, '');\n    } else {\n        node.textContent = '';\n    }\n\n    scopeInfo.bindings.push(binding);\n};\n\n/**\n * binds an object expression to node.className.\n *\n * @param  {string} text      the initial text value of the binding node\n * @param  {Node}   node        the binding node\n * @param  {Object} scopeInfo the meta data of the current scope\n * @param  {Node}   parentNode  the parent of the binding node\n *\n * @return {void}\n */\nlet bindClasses = function(text, node, scopeInfo, parentNode) {\n    let binding = Make({\n        originalNodeValue : text,\n        node : node,\n        classes : ObjectParser(text),\n        parentNode : parentNode\n    }, ClassBinding).get();\n\n    scopeInfo.bindings.push(binding);\n};\n\n/**\n * binds an expression to the disabled attribute.\n *\n * @param  {string} text       the initial value of the binding node\n * @param  {Object} scopeInfo  the meta data of the current scope\n * @param  {Node}   parentNode the parent of the binding node\n *\n * @return {void}\n */\nlet bindEnabled = function(text, scopeInfo, parentNode) {\n    let binding = Make({\n        originalNodeValue : text,\n        parentNode : parentNode\n    }, EnabledBinding)();\n\n    scopeInfo.bindings.push(binding);\n};\n\n/**\n * Binds the events specified for a Node\n *\n * @param {string[]}                          events a string representation of the object with all the event / expression pairs.\n * @param {Node}                              node   the node on which the event listeners should be registered.\n * @param {module:DataBinding~ScopePrototype} scope  the data scope on which the binding happens.\n * @return {void}\n */\nlet bindEvents = function(events, node, scope){\n    events = ObjectParser(events);\n\n    Object.keys(events).forEach(name => {\n        let [method, modifier] = events[name].split('|');\n\n        if (scope.$methods && scope.$methods[method.trim()]) {\n            node.addEventListener(name.trim(), e => {\n                scope.$methods[method.trim()].apply(scope, [e]);\n\n                scope.__apply__();\n            });\n        } else {\n            method = parseExpression(method.trim(), scope);\n\n            node.addEventListener(name.trim(), e => {\n                let canceled = false;\n\n                e.cancleRecycle = function(){\n                    canceled = true;\n                };\n\n                method.apply(scope, [e]);\n\n                if (!canceled) {\n                    if (scope.isIsolated) {\n                        scope.update();\n                    } else {\n                        scope.__apply__();\n                    }\n                }\n            }, modifier === 'capture');\n        }\n    });\n};\n\n/**\n * automatically binds a template to a property of the current scope\n *\n * @param  {string} text      the binding text\n * @param  {Object} scopeInfo the meta data of the current scope\n * @param  {Node}   template  the template node\n *\n * @return {void}\n */\nlet bindAuto = function(text, scopeInfo, template) {\n    let binding = Make({\n        scopeName : text,\n        template : template\n    }, AutoBinding)();\n\n    scopeInfo.bindings.push(binding);\n};\n\n/**\n * binds visual properties to the scope\n *\n * @param  {string}                            text       the binding text\n * @param  {Object}                            scopeInfo  the meta data of the scope\n * @param  {module:DataBinding~ScopePrototype} scope      the current scope\n * @param  {Node}                              parentNode the parent of the binding node\n *\n * @return {void}\n */\nlet bindStyle = function(text, scopeInfo, scope, parentNode) {\n    let binding = Make({\n        bindings: text,\n        parentNode: parentNode,\n    }, StyleBinding)(scope);\n\n    scopeInfo.bindings.push(binding);\n};\n\n/**\n * executes every watcher for the given scope.\n *\n * @param  {module:DataBinding~ScopePrototype} scope the current scope\n *\n * @return {void}\n */\nlet executeWatchers = function(scope) {\n    watcherList.get(scope) && watcherList.get(scope).forEach(watcher => {\n        let value = parseExpression(watcher.expression, scope);\n\n        expressionTracking[watcher.expression] = expressionTracking[watcher.expression] || { value : '', newValue : '' };\n\n        if (expressionTracking[watcher.expression].value !== value) {\n            watcher.cb.apply(scope, [value]);\n\n            expressionTracking[watcher.expression].newValue = value;\n        }\n    });\n};\n\n/**\n * Checks every binding for the given scope and updates every value.\n *\n * @function\n * @param {module:DataBinding~ScopePrototype} [scope] the scope to recycle\n *\n * @return {void}\n */\nexport let recycle = function (scope) {\n\n    RenderEngine.scheduleRenderTask(() => {\n        const t0 = window.performance.now();\n        const bindigMeasures = [];\n\n        try {\n            if (scope) {\n                const scopeMetaData = scopeList.get(scope);\n\n                drainScopeUpdates(scope, scopeMetaData);\n                executeWatchers(scope);\n\n                scopeMetaData.bindings.forEach((/** @type {Binding} */binding) => {\n                    const start = Math.round(window.performance.now());\n                    binding.update(scope);\n                    const end = Math.round(window.performance.now());\n\n                    bindigMeasures.push([`binding checked in ${end - start}ms`, binding]);\n                });\n\n            } else {\n                scopeIndex.forEach(scope => {\n                    const scopeMetaData = scopeList.get(scope);\n\n                    drainScopeUpdates(scope, scopeMetaData);\n                    executeWatchers(scope);\n\n                    scopeMetaData.bindings.forEach((/** @type {Binding} */binding) => {\n                        binding.update(scope);\n                    });\n                });\n            }\n\n            Object.keys(expressionTracking).forEach(expr => {\n                expr = expressionTracking[expr];\n\n                expr.value = expr.newValue;\n            });\n        } catch (e) {\n            console.error(e);\n        }\n\n        let t1 = window.performance.now();\n        let duration = ((t1 - t0) / 1000);\n        let color = null;\n        let renderTimeExeeded = false;\n\n        if (duration >= 0.033) {\n            color = 'red';\n            renderTimeExeeded = true;\n        } else if (duration >= 0.016) {\n            color = 'yellow';\n            renderTimeExeeded = true;\n        } else {\n            color = 'green';\n        }\n\n        color = `color: ${color};`;\n        duration = duration.toFixed(2);\n\n        if (scope) {\n            console.log(`scope recycled in %c${duration}s`, color, renderTimeExeeded ? scope : '');\n            if (CurrentConfig.verboseLogging) {\n                bindigMeasures.forEach((item) => {\n                    console.log(...item);\n                });\n            }\n        } else {\n            console.log(`full recycle in %c${duration}s`, color);\n        }\n\n    }, scope || 'DataBindingRecycle');\n};\n\n/**\n * destories a scope.\n *\n * @function\n * @param {module:DataBinding~ScopePrototype} scope the scope to destory\n * @param {boolean} inProgress                indicates if this is an initial call or not.\n *\n * @return {void}\n */\nexport let destoryScope = function(scope, inProgress) {\n    console.log(scopeList);\n    let scopeInfo = scopeList.get(scope);\n\n    let [scopes, bindings] = scopeInfo.bindings.reduce((prev, binding) => {\n        let [scopes, bindings] = prev;\n\n        if (binding.destory) {\n            let [scopes_add, bindings_add] = binding.destory();\n\n            scopes += scopes_add;\n            bindings += bindings_add;\n        }\n\n        return [scopes, bindings];\n    }, [0, 0]);\n\n    bindings += scopeInfo.bindings.length;\n    scopes += 1;\n\n    scopeList.delete(scope);\n    scopeIndex.splice(scopeIndex.indexOf(scope), 1);\n    watcherList.delete(scope);\n\n    if (inProgress) {\n        return [scopes, bindings];\n    } else {\n        console.log(`${scopes} scopes and ${bindings} bindings cleaned!`);\n    }\n};\n\n/**\n * Returns the value of an DOM Node\n *\n * @param {Node} node the node to fetch the value from\n *\n * @return {string} value of this node\n */\nlet getElementValue = function(node){\n    if (node.localName === 'input') {\n        return node.value;\n    } else {\n        return 'UNKNOWN NODE!';\n    }\n};\n\nconst drainScopeUpdates = function(scope, scopeMetaData) {\n    scopeMetaData.scheduledTasks.forEach(task => {\n        task(scope);\n    });\n\n    scopeMetaData.scheduledTasks.length = 0;\n};\n\nexport const scheduleScopeUpdate = function(scopeInfo, callback) {\n    if (!callback) {\n        console.error('unable to schedule an empty task!');\n        return;\n    }\n\n    if (typeof callback !== 'function') {\n        console.error('task is not a function!');\n        return;\n    }\n\n    scopeInfo.scheduledTasks.push(callback);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/Bind.js\n// module id = 8\n// module chunks = 0","/**\n * @module NetworkRequest\n */\n\n\n/**\n * removes angulars hashKey property from an object\n *\n * @param {Object} object the object to operate on\n *\n * @return {Object} the initial object\n */\nlet stripHashKey = function(object){\n    if (Array.isArray(object)) {\n        object = object.map(stripHashKey);\n\n    } else {\n        object = JSON.parse(JSON.stringify(object));\n\n        Object.keys(object).forEach((key) => {\n            if (key == '$$hashKey') {\n                delete object[key];\n            }else if (typeof object[key] === 'object' ) {\n                object[key] = stripHashKey(object[key]);\n            }\n        });\n    }\n\n    return object;\n};\n\n/**\n * @lends module:NetworkRequest.NetworkRequest#\n */\nlet NetworkRequest = {\n    /**\n     * @private\n     * @type {Object}\n     */\n    _body : {},\n\n    /**\n     * @private\n     * @type {Object}\n     */\n    _headers : null,\n\n    /**\n     * @type {string}\n     */\n    type : '',\n\n    /**\n     * @type {string}\n     */\n    method : '',\n\n    /**\n     * @type {string}\n     */\n    url : '',\n\n    /**\n     * @type {function[]}\n     * @private\n     */\n    _listeners : null,\n\n\t/**\n\t * The constructor for the NetworkRequest. It simply sets up the properties.\n\t *\n\t * @constructs\n\t *\n\t * @param {string} url the url this request should be made to\n\t * @param {Object} config addintional configuartion for the request\n\t *\n\t * @return {NetworkRequest} the request it self\n\t */\n    constructor (url, { method = 'GET', type = 'none' } = {}) {\n        this.type = type;\n        this.method = method;\n        this._headers = {};\n        this.url = url;\n        this._listeners = [];\n\n        return this;\n    },\n\n    /**\n     * [_make description]\n     *\n     * @deprecated use the constructor\n     * @param  {[type]} args [description]\n     * @return {[type]}      [description]\n     */\n    _make(...args) {\n        return this.constructor(...args);\n    },\n\n\t/**\n\t * this method will set the given object as the request body.\n\t *\n\t * @param {Object} data body data for this request\n\t *\n\t * @return {NetworkRequest} the request it self\n\t */\n    body : function(data){\n        this._body = data;\n\n        return this;\n    },\n\n\t/**\n\t * This method will set the request headers, in case custom headers are required.\n\t *\n\t * @param {Object} headers a object with all header properties for this request\n\t *\n\t * @return {NetworkRequest} the request it self\n\t */\n    headers : function(headers) {\n        this._headers = headers;\n\n        return this;\n    },\n\n    /**\n     * Sets a single header for this request.\n     *\n     * @param {string} key the header key\n     * @param {string} value the header value\n     *\n     * @return {NetworkRequest} the request it self\n     */\n    setHeader : function(key, value) {\n        this._headers[key] = value;\n\n        return this;\n    },\n\n    /**\n     * sets a callback for when the request is ready\n     *\n     * @param {function} fn a callback function as soon as the data is ready\n     *\n     * @return {void}\n     */\n    onReady : function(fn){\n        this._listeners.push(fn);\n    },\n\n\t/**\n\t * This will actually create the network connection and initiate the request.\n\t *\n\t * @return {Promise} resolves when the request is done\n\t */\n    send : function(){\n        let self = this;\n        let xhr = new XMLHttpRequest();\n\n        if (this.method === 'GET' && this._body) {\n            this.url += '?' + Object.keys(this._body).map((key) => {\n                return `${key}=${self._body[key]}`;\n            }).join('&');\n        }\n\n        xhr.open(this.method, this.url, true);\n\n        let promise = new Promise((success, failure) => {\n            xhr.onreadystatechange = () => {\n                if (xhr.readyState === 4) {\n                    if (xhr.status >= 200 && xhr.status < 300) {\n                        let response = xhr.response;\n\n                        if (xhr.getResponseHeader('Content-Type').indexOf('application/json') > -1 && typeof response  === 'string') {\n                            response = JSON.parse(response);\n                        }\n\n                        this._listeners.forEach(fn => fn(xhr));\n\n                        success(response);\n                    } else {\n                        failure(xhr);\n                    }\n                }\n            };\n        });\n\n        Object.keys(this._headers).forEach((key) => {\n            xhr.setRequestHeader(key, self._headers[key]);\n        });\n\n        if (this.type === 'json') {\n            let body = this._body;\n\n            xhr.setRequestHeader('Content-Type', 'application/json');\n\n            if (body){\n                body = stripHashKey(body);\n                body = JSON.stringify(body);\n            }\n\n            xhr.send(body);\n        } else {\n            xhr.send(this._body);\n        }\n\n        return promise;\n    }\n};\n\nexport default NetworkRequest;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/application-frame/core/NetworkRequest.js\n// module id = 9\n// module chunks = 0","import DataStorage from 'application-frame/core/DataStorage';\n\nconst { create } = Object;\n\nconst store = create(DataStorage).constructor();\n\nstore.fill({});\n\n\nexport { store as SelectedProperties };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./SelectedProperties.js\n// module id = 10\n// module chunks = 0","import async from './async';\n\n/** @lends EventTarget# */\nconst EventTarget = {\n\n    /** @type {Object} */\n    _listeners : null,\n\n    /**\n     * @constructs\n     *\n     * @return {this} [description]\n     */\n    constructor() {\n        this._listeners = {};\n\n        return this;\n    },\n\n    /**\n     * @deprecated Do not use the make constructors\n     *\n     * @return {this}      [description]\n     */\n    _make(...args) {\n        return this.constructor(...args);\n    },\n\n    /**\n     * registers a new listener for the given event.\n     *\n     * @param {string} type the type of event\n     * @param {function} listener callback to execute when the event fires\n     *\n     * @return {void}\n     */\n    on : function(type, listener){\n        if (!this._listeners[type]) {\n            this._listeners[type] = [];\n        }\n\n        this._listeners[type].push(listener);\n    },\n\n    /**\n     * emmits a new event on this object\n     *\n     * @param {string} type the type of event\n     * @param {*} data data to send to the callbacks\n     *\n     * @return {void}\n     */\n    emit : function(type, data){\n        if (this._listeners[type]) {\n            async(() => {\n                this._listeners[type]\n                    .forEach(listener => listener.apply(this, [data]));\n            });\n        }\n    },\n\n    /**\n    * removes a previously attached listener function.\n    *\n    * @param  {string} type     the listener type\n    * @param  {Function} listener the listener function to remove\n    *\n    * @return {void}\n    */\n    removeListener: function(type, listener) {\n        if (this._listeners[type]) {\n            const index = this._listeners[type].indexOf(listener);\n\n            this._listeners[type].splice(index, 1);\n        }\n    },\n};\n\nexport default EventTarget;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/application-frame/core/EventTarget.js\n// module id = 11\n// module chunks = 0","const heapObjects = new Map();\nconst heapObjectsReleased = {};\nconst heapArrays = new Map();\nconst heapArraysReleased = [];\n\nexport const allocate = function(typeOrLength, prototype={}) {\n    if (typeof typeOrLength === 'string') {\n        let object = null;\n\n        if (heapObjectsReleased[typeOrLength] && heapObjectsReleased[typeOrLength].length) {\n            object = heapObjectsReleased[typeOrLength].shift();\n        } else {\n            if (prototype === WeakMap.prototype) {\n                object = new prototype.constructor();\n            } else {\n                object = Object.create(prototype);\n                object.constructor();\n            }\n        }\n\n        heapObjects.set(object, typeOrLength);\n\n        return object;\n    } else {\n        let array = heapArraysReleased.shift();\n\n        if (!array) {\n            array = [];\n        }\n\n        array.length = typeOrLength;\n        heapArrays.set(array, true);\n\n        return array;\n    }\n};\n\nexport const release = function(object) {\n    if (Array.isArray(object)) {\n        heapArrays.delete(object);\n        heapArraysReleased.push(object);\n    } else {\n        const type = heapObjects.get(object);\n\n        heapObjects.delete(object);\n\n        if (!heapObjectsReleased[type]) {\n            heapObjectsReleased[type] = [];\n            heapObjectsReleased[type].push(object);\n        }\n    }\n};\n\nexport const flushHeap = function() {\n    heapArraysReleased.length = 0;\n\n    Object.keys(heapObjectsReleased).forEach(key => {\n        delete heapObjectsReleased[key];\n    });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/application-frame/memory/index.js\n// module id = 12\n// module chunks = 0","import ViewController from '@af-modules/databinding/prototypes/ViewController';\n\nimport { SelectedProperties } from '../SelectedProperties';\nimport PropertyTypes from '../PropertyTypes';\nimport { ArticleStore } from '../ArticleStore';\nimport { suggestMostCommonPropType } from '../modules/PropertyAssistant';\n\nconst { create } = Object;\n\nconst MessagesList = {\n\n    _list: null,\n    _callbacks: null,\n\n    constructor() {\n        this._list = [];\n        this._callbacks = [];\n\n        return this;\n    },\n\n    add(message) {\n        this._list.push(message);\n\n        this._callbacks.forEach(callback => callback(this._list));\n    },\n\n    when(callback) {\n        this._callbacks.push(callback);\n    },\n\n    getItems() {\n        return this._list;\n    },\n\n    get length() {\n        return this._list.length;\n    },\n\n    set length(value) {\n        this._list.length = value;\n    }\n};\n\n\nconst AssistantChatView = {\n    template: 'assistant-chat',\n\n    messages: null,\n\n    init() {\n        this.constructor();\n        this.messages = create(MessagesList).constructor();\n        this.messages.when(this.scope.update.bind(this.scope));\n    },\n\n    selectedProperties: SelectedProperties,\n\n    startSession() {\n        this.messages.length = 0;\n\n        const primary = this.pickPrimary();\n        const notPrimary = this.pickOthers();\n\n        this.postMessage(`So you are looking for a ${notPrimary.join(' ')} ${primary.join(' ')}?`);\n        this.generateNextSugestion();\n    },\n\n    pickPrimary() {\n        const list = this.selectedProperties.value;\n        return Object.keys(list)\n            .filter(key => !!PropertyTypes.find(type => type.name === key).primary)\n            .map(key => list[key].join(' '));\n    },\n\n    pickOthers() {\n        const list = this.selectedProperties.value;\n\n        return Object.keys(list)\n            .filter(key => !PropertyTypes.find(type => type.name === key).primary)\n            .map(key => list[key].join(' '));\n    },\n\n    postMessage(text) {\n        const message = {\n            type: 'out',\n            text,\n        };\n\n        this.messages.add(message);\n    },\n\n    getUnusedProperties() {\n        const list = this.selectedProperties.value;\n        const unused = PropertyTypes.filter(prop => Object.keys(list).indexOf(prop.name) < 0);\n\n        return unused;\n    },\n\n    generateNextSugestion() {\n        const unused = this.getUnusedProperties();\n\n        const result = suggestMostCommonPropType(ArticleStore.value, unused);\n        const currentArticleCount = ArticleStore.value.length;\n\n        this.postMessage(`We have ${currentArticleCount} Articles matching your description.`);\n        this.postMessage(`What kind of ${result.name} do you prefer?`);\n    },\n\n    __proto__: ViewController,\n};\n\nexport default AssistantChatView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./views/AssistantChatView.js\n// module id = 13\n// module chunks = 0","/**\n * DataBinding Module\n *\n * @module DataBinding\n * @default module:DataBinding.DataBinding\n */\nimport { makeTemplate, createTemplateInstance } from './lib/Template.js';\nimport { polyInvoke } from './lib/Util.js';\nimport ViewPort from './lib/ViewPort.js';\nimport './lib/IfBinding.js';\nimport './lib/ElementToScopeBinding.js';\nimport './lib/HtmlBinding.js';\nimport './lib/CloakBinding.js';\nimport './lib/bindings/AttributeBinding';\nimport './lib/bindings/AnimationBinding';\nimport './lib/bindings/TemplateRepeatBinding';\nimport './lib/bindings/EventBinding';\n\n\nNodeList.prototype.forEach = NamedNodeMap.prototype.forEach = Array.prototype.forEach;\n\nlet style = document.createElement('style');\n\nstyle.innerHTML = `\n    :not(.animated) > :not(.animated) > :not(.animated) > [bind-display=\"false\"]:not(.animated) {\n        display: none !important;\n    }\n\n    :not(.animated) > :not(.animated) > :not(.animated) > [bind-visible=\"false\"]:not(.animated) {\n        visibility: hidden;\n    }\n`;\n\npolyInvoke(document.head).appendChild(style);\n\n/**\n * [DataBinding description]\n *\n * @type {module:DataBinding.ModuleInterface}\n */\nexport let DataBinding = {\n    makeTemplate : makeTemplate,\n    ViewPort : ViewPort,\n    createTemplateInstance: createTemplateInstance,\n};\n\nexport { ANIMATION_BINDING_LOOPED } from './lib/bindings/AnimationBinding';\nexport { default as BindingApi } from './lib/BindingApi';\n\nexport default DataBinding;\n\n/**\n * @interface ModuleInterface\n * @borrows module:DataBinding/Bind.bindNode as bindNode\n * @borrows module:DataBinding/Template.makeTemplate as makeTemplate\n * @borrows module:DataBinding/ViewPort.ViewPort\n * @static\n *\n */\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/main.js\n// module id = 14\n// module chunks = 0","/**\n * @module DataBinding/Template\n */\n\nimport { Make } from '../af/util/make.js';\nimport { bindNode } from './Bind.js';\nimport { getPolyParent, polyInvoke } from './Util.js';\nimport { importTemplate } from './TemplateLoader.js';\nimport { parseExpression } from './Parser';\nimport { RenderEngine } from 'application-frame/rendering';\nimport ScopePrototype from './ScopePrototype.js';\n\n/**\n * Instanciates a template based on a specified element.\n *\n * @param  {HTMLTemplateElement}               template    the template to instanciate\n * @param  {module:DataBinding.ScopePrototype} scope       the scope to operate on\n * @param  {Application}                       application the application this binding belongs to\n * @param  {Node}                              item        the original node\n *\n * @return {void}\n */\nlet makeElementFromTemplate = function(template, scope, application, item) {\n    RenderEngine.schedulePostRenderTask(() => {\n        let node = document.importNode(template.content, true);\n        let placeholder = node.querySelector('bind-placeholder');\n\n        item.attributes.forEach(attr => {\n            polyInvoke(node.firstElementChild).setAttribute(attr.name, attr.value);\n        });\n\n        if (placeholder) {\n            let node = item.firstElementChild;\n            polyInvoke(placeholder.parentNode).replaceChild(item.firstElementChild, placeholder);\n\n            [].forEach.apply(item.children, [item => {\n                polyInvoke(node.parentNode).appendChild(item);\n            }]);\n        }\n\n        node.firstElementChild.className = template.id + ' ' + node.firstElementChild.className;\n\n        scope = scope();\n\n        [].map.apply(node.firstElementChild.attributes, [item => {\n            if (item.name.search(/^scope\\-/) > -1 ) {\n                scope[item.name.replace(/^scope\\-/, '')] = item.value;\n            }\n        }]);\n\n        if (template.hasAttribute('component')) {\n            scope.element = node.firstElementChild;\n        }\n\n        scope = bindNode(node, scope);\n\n        polyInvoke(item.parentNode).replaceChild(node, item);\n\n        if (application) {\n            application.emit(`newElement:${template.id}`, scope);\n        }\n    });\n};\n\n/**\n * creates a new instance of an HTML template and applies the binding with\n * the given scope.\n *\n * @function\n * @deprecated Please use the new createTemplateInstance()\n *\n * @param {Node|string} template - the template to render\n * @param {ScopePrototype} scope - the scope for this template to bind to\n * @param {Application} [application] - the application this template belongs to\n * @param {ScopePrototype} [parentScope] - the surounding scope of this template node\n *\n * @return {Object} - collection of scope and rendered element\n */\nexport let makeTemplate = function (template, scope, application, parentScope) {\n    template = (typeof template === 'string') ? document.querySelector(template) : template;\n\n    if (template.hasAttribute('src') && !template.processed) {\n        let source = template.getAttribute('src');\n\n        if (parentScope) {\n            let value = parseExpression(source, parentScope);\n\n            source = (value && value != '') ? value : source;\n        }\n\n        scope = Make(scope, ScopePrototype)();\n\n        importTemplate(source, template)\n            .then(template => {\n                template.processed = true;\n                makeTemplate(template, scope, application, parentScope);\n            });\n\n        return scope;\n\n    } else if (template.hasAttribute('bind-element')) {\n        let makeElement = makeElementFromTemplate.bind(this, template, scope, application);\n        let list = document.querySelectorAll(template.id);\n\n        [].forEach.apply(list, [makeElement]);\n\n        (new MutationObserver(mutations => {\n            mutations.forEach(item => {\n                if (item.addedNodes.length > 0) {\n                    let list = [].map.apply(item.addedNodes, [node => {\n                        return node.querySelectorAll ? [].slice.apply(node.querySelectorAll(template.id)) : [];\n                    }]).reduce((prev, next) => prev.concat(next), []);\n\n                    list = list.concat([].filter.apply(item.addedNodes, [node => node.localName === template.id]));\n\n                    [].forEach.apply(list, [makeElement]);\n                }\n            });\n        })).observe(document.body, {\n            childList : true,\n            subtree : true\n        });\n\n    } else {\n        let node = document.importNode(template.content, true);\n        let isReplace = template.hasAttribute('replace');\n        let isInsert = template.hasAttribute('insert');\n\n        scope = bindNode(node, scope);\n\n        if (isReplace || isInsert) {\n            let elementList = [].slice.apply(node.childNodes);\n\n            scope.__cleanElements__ = function(){\n                elementList.forEach(node => {\n                    node.parentNode && node.parentNode.removeChild(node);\n                });\n            };\n        }\n\n        let parentNode = template.parentNode;\n\n        if (template.getAttribute('poly-parent')) {\n            let parentName = template.getAttribute('poly-parent');\n\n            parentNode = getPolyParent(template, parentName);\n        }\n\n        if (isReplace) {\n            console.log('replace template');\n\n            polyInvoke(parentNode).replaceChild(node, template);\n        } else if (isInsert) {\n            polyInvoke(parentNode).insertBefore(node, template);\n        }\n\n        return { node : node, scope : scope };\n    }\n};\n\nconst fetchExternalTemplate = function({ template, parentScope }) {\n    let source = template.getAttribute('src');\n\n    if (parentScope) {\n        let value = parseExpression(source, parentScope);\n\n        source = (value && value != '') ? value : source;\n    }\n\n    return importTemplate(source, template)\n        .then(template => {\n            template.processed = true;\n\n            return template;\n        });\n};\n\n/**\n * Instanciates a template and either replaces the template node in the DOM or\n * simply returns the node and it's scope.\n *\n * @param  {string|HTMLTemplateElement} template\n * @param  {Object} [scope={}]\n * @param  {Application} [application=null]\n * @param  {ScopePrototype} [parentScope]\n * @return { node: HTMLElement, scope: ScopePrototype } the resulting element and scope\n */\nexport const createTemplateInstance = function({ template, scope = {}, application = null, parentScope }) {\n    template = (typeof template === 'string') ? document.querySelector(template) : template;\n\n    if (template.hasAttribute('src') && !template.processed) {\n        return fetchExternalTemplate({ template: template, parentScope: parentScope })\n            .then(template => makeTemplate({ template, scope, application, parentScope }));\n    }\n\n    const node = document.importNode(template.content, true);\n    const isReplace = template.hasAttribute('replace');\n\n    scope = ({ view: scope, isIsolated: true, __proto__: ScopePrototype }).constructor();\n\n    bindNode(node, scope, true);\n\n    if (isReplace) {\n        let elementList = [].slice.apply(node.childNodes);\n\n        scope.__cleanElements__ = function() {\n            elementList.forEach(node => {\n                node.parentNode && node.parentNode.removeChild(node);\n            });\n        };\n    }\n\n    if (isReplace) {\n        let parentNode = template.parentNode;\n\n        if (template.getAttribute('poly-parent')) {\n            let parentName = template.getAttribute('poly-parent');\n\n            parentNode = getPolyParent(template, parentName);\n        }\n\n        polyInvoke(parentNode).replaceChild(node, template);\n    }\n\n    return { node : node, scope : scope };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/Template.js\n// module id = 15\n// module chunks = 0","/**\n * @module DataBinding/Mapping\n */\n\n/**\n * Contains all the attribute names\n *\n * @namespace\n */\nexport let attributeNames = {\n    events : 'events',\n    visible : 'display',\n    transparent : 'visible',\n    classes : 'class',\n    value : 'value',\n    prefix : 'bind',\n    enabled : 'enabled',\n    model : 'model',\n    modelEvent : 'model-event',\n\n    /**\n     * returns the value for a key\n     *\n     * @param  {string} key the key to lookup\n     *\n     * @return {string}     the coresponding value\n     */\n    get : function(key){\n        return `${this.prefix}-${this[key]}`;\n    },\n\n    /**\n     * cuts off the prefix of the name\n     *\n     * @param  {string} name initial value\n     *\n     * @return {string}      the clean value\n     */\n    rename : function(name){\n        return name.replace(`${this.prefix}\\-`, '');\n    }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/Mapping.js\n// module id = 16\n// module chunks = 0","const CurrentFrameInterface = {\n    _startTime: 0,\n    _maxFrameDuration: 0,\n\n    constructor({ startTime, maxFrameDuration } = {}) {\n        this._startTime = startTime;\n        this._maxFrameDuration = maxFrameDuration;\n\n        return this;\n    },\n\n    ttl() {\n        const duration = performance.now() - this._startTime;\n        const ttl = this._maxFrameDuration - duration;\n\n        return ttl;\n    },\n\n    INTERUPT_CURRENT_TASK: Symbol('INTERUPT_CURRENT_TASK'),\n};\n\nexport default CurrentFrameInterface;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/application-frame/rendering/CurrentFrameInterface.js\n// module id = 17\n// module chunks = 0","import { parseExpression } from './Parser';\nimport { recycle, watcherList, destoryScope } from './Bind.js';\n\n/**\n * @class ScopePrototype\n * @memberof module:DataBinding\n */\n\n/**\n * @lends module:DataBinding.ScopePrototype.prototype\n */\nlet ScopePrototype = {\n\n    _make: function() {\n        this.constructor();\n    },\n\n    constructor() {\n        this.__apply__ = this.__apply__.bind(this);\n\n        return this;\n    },\n\n    /**\n    * will apply the current state of the bound model.\n    *\n    * @deprecated Please use update()\n    *\n    * @param {function} [fn]            function to execute before rendering\n    * @param {boolean} [localRecycle]   only recycle the current scope\n    *\n    * @return {void}\n    */\n    __apply__ : function(fn, localRecycle){\n        if (fn && typeof fn === 'function') {\n            fn();\n        }\n\n        return recycle(localRecycle ? this : null);\n    },\n\n    update() {\n        return recycle(this);\n    },\n\n    /**\n     * starts to watch the given expression and fires when the value changes.\n     *\n     * @param  {string}   expression the expression to watch\n     * @param  {Function} cb         will be called once the value changes\n     *\n     * @return {void}\n     */\n    __watch__ : function(expression, cb) {\n        if (!watcherList.has(this)) {\n            watcherList.set(this, []);\n        }\n\n        watcherList.get(this).push({\n            expression : expression,\n            cb : cb\n        });\n    },\n\n    /**\n     * destorys a scope\n     *\n     * @param  {boolean} inProgress whenever this is an initial call or not\n     *\n     * @return {boolean} status\n     */\n    __destroy__ : function(inProgress) {\n        return destoryScope(this, inProgress);\n    },\n\n    /**\n    * resolves when the expression returns not undefined or null\n    *\n    * @param  {string|Function}   expression the expression to evaluate\n    *\n    * @return {Promise}                      resolves when stable\n    */\n    require: function(expression) {\n        return new Promise((done) => {\n            let value = null;\n\n            if (typeof expression === 'function') {\n                value = expression();\n            } else {\n                value = parseExpression(expression, this);\n            }\n\n            if (value !== undefined && value !== null) {\n                done(value);\n            }\n        });\n    }\n};\n\nexport default ScopePrototype;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/ScopePrototype.js\n// module id = 18\n// module chunks = 0","import BindingRegistry from '../BindingRegistry';\nimport Binding from '../Binding';\nimport { ObjectParser, parseExpression } from '../Parser';\nimport EventTarget from '../../af/core/EventTarget';\nimport { hasPrototype } from '../../af/util/make';\n\nexport const ANIMATION_BINDING_LOOPED = Symbol('ANIMATION_BINDING_LOOPED');\n\n/**\n * [AnimationBinding description]\n *\n * @lends {AnimationBinding#}\n * @extends {module:DataBinding.Binding}\n */\nconst AnimationBinding = {\n\n    name: 'bind-animation',\n\n    /**\n     * [animations description]\n     *\n     * @type {Object}\n     */\n    animations: null,\n\n    /**\n     * @type {node}\n     */\n    parentNode: null,\n\n    playing: null,\n\n    lastConditionStatus: null,\n\n    /**\n     *\n     * @constructs\n     * @extends {Binding}\n     * @param {Node} parentNode - this node\n     * @param {string} text - the attribute value\n     * @param {ScopeInfo} scopeInfo - bindings container\n     *\n     * @return {void}\n     */\n    _make({ parentNode, text, scopeInfo }) {\n        this.animations = ObjectParser(text);\n        this.parentNode = parentNode;\n        this.playing = {};\n        this.lastConditionStatus = {};\n\n        scopeInfo.bindings.push(this);\n    },\n\n    /**\n     * @param {module:DataBinding.ScopePrototype} scope\n     */\n    update(scope) {\n        Object.keys(this.animations).forEach(conditionExpression => {\n            const conditionValue = parseExpression(conditionExpression, scope);\n            const conditionValueChanged = conditionValue !== this.lastConditionStatus[conditionExpression];\n\n            if (conditionValue === '') {\n                return;\n            }\n\n            this.lastConditionStatus[conditionExpression] = conditionValue;\n\n            if (!conditionValueChanged && conditionValue !== ANIMATION_BINDING_LOOPED) {\n                return;\n            }\n\n            const animationExpression = this.animations[conditionExpression];\n            const animation = parseExpression(animationExpression, scope);\n\n            if (!animation) {\n                const animationPath = animationExpression.split('.');\n                const animationName = animationPath.pop();\n\n                console.error(`animation ${animationName} does not exist on ${animationPath}!`);\n                return;\n            }\n\n            if (conditionValue && !this.playing[conditionExpression]) {\n                let parent = animationExpression.split('.');\n\n                parent.pop();\n                parent = parent.join('.');\n                parent = parseExpression(parent, scope);\n\n                if (!parent) {\n                    parent = scope;\n                }\n\n                this.parentNode.classList.add('animated');\n                this.playing[conditionExpression] = true;\n\n                const result = animation.apply(parent, [this.parentNode]);\n\n                if (!scope.$animation) {\n                    const a = Object.create(EventTarget);\n\n                    a._make();\n                    scope.$animation = a;\n                }\n\n                if (result === null || result === undefined) {\n                    console.warn(`[Animation Binding] ${animationExpression} did not return a result value.`);\n                }\n\n                if (typeof result === 'object' && hasPrototype(result, Promise)) {\n                    result.then(this.finishAnimation.bind(this, conditionExpression, animation, scope));\n                } else {\n                    this.finishAnimation(conditionExpression, animation, scope);\n                }\n            }\n        });\n    },\n\n    finishAnimation(conditionExpression, animation, scope) {\n        this.playing[conditionExpression] = false;\n        this.parentNode.classList.remove('animated');\n        scope.$animation.emit(animation.name, null);\n    },\n\n    __proto__: Binding,\n};\n\nBindingRegistry.register(AnimationBinding);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/bindings/AnimationBinding.js\n// module id = 19\n// module chunks = 0","import EventTarget from './EventTarget';\n\nconst whenFilled = function(successCallback) {\n    if (successCallback && typeof successCallback === 'function') {\n        this._filledCallbacks.push({ once: false, callback: successCallback });\n    }\n\n    if (this._value) {\n        successCallback(this._value);\n    }\n};\n\nconst whenNext = function(callback) {\n    if (callback && typeof callback === 'function') {\n        this._filledCallbacks.push({ once: true, callback: callback });\n    }\n};\n\nconst once = function(callback) {\n    if (callback && typeof callback === 'function') {\n        if (!this._value) {\n            this._filledCallbacks.push({ once: true, callback: callback });\n        } else {\n            callback(this._value);\n        }\n    }\n};\n\n// fake then if this should be handed to something that expects a promise\nwhenFilled.then = whenNext.then = once.then = function(callback) {\n    return (new Promise((done) => {\n        this(done);\n    })).then(callback);\n};\n\n// dummy catch in case someone tries to use it\nwhenFilled.catch = whenNext.catch = once.catch = function(callback) {\n    return (new Promise((done) => {\n        this(done);\n    })).catch(callback);\n};\n\nconst DataStorage = {\n    _value: null,\n    _filledCallbacks: [],\n\n    get value() {\n        return this._value;\n    },\n\n    constructor() {\n        this.when = whenFilled.bind(this);\n        this.whenNext = whenNext.bind(this);\n        this.once = once.bind(this);\n        this._filledCallbacks = [];\n\n        return this;\n    },\n\n    fill(value) {\n        this._value = value;\n\n        this._filledCallbacks = this._filledCallbacks.filter(item => {\n            item.callback(this._value);\n            return !item.once;\n        });\n    },\n\n    when: null,\n\n    once: null,\n\n    whenNext: null,\n\n    __proto__: EventTarget,\n};\n\nexport default DataStorage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/application-frame/core/DataStorage.js\n// module id = 20\n// module chunks = 0","import NetworkRequest from 'application-frame/core/NetworkRequest';\n\nconst { create } = Object;\n\nconst types = [];\n\nconst request = create(NetworkRequest).constructor('./data/propertyTypes.json', { type: 'json' });\n\nrequest.send().then(data => {\n    types.push(...data);\n});\n\nexport default types;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./PropertyTypes.js\n// module id = 21\n// module chunks = 0","import DataStorage from 'application-frame/core/DataStorage';\nimport NetworkRequest from 'application-frame/core/NetworkRequest';\nimport { scrapProperties } from './modules/ArticlePropertyScraper';\nimport PropertyTypes from './PropertyTypes';\nimport { SelectedProperties } from './SelectedProperties';\n\nconst { create } = Object;\n\nconst store = create(DataStorage).constructor();\nlet allArticles = null;\n\nconst request = create(NetworkRequest).constructor('./data/products.json');\n\nrequest.type = 'json';\n\nrequest.send().then(result => {\n    allArticles = result;\n    restoreAllArticles(store);\n});\n\nSelectedProperties.when(list => {\n    filterArticles(store, list);\n});\n\nexport const restoreAllArticles = function(store) {\n    store.fill(JSON.parse(JSON.stringify(allArticles)));\n};\n\nexport const filterArticles = function(store, sProperties) {\n    const list = store.value;\n\n    list.filter(article => {\n        const properties = scrapProperties({ article, propertyDef: PropertyTypes });\n\n        console.log(properties);\n    });\n};\n\nexport { store as ArticleStore };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./ArticleStore.js\n// module id = 22\n// module chunks = 0","export const scrapeFromArticles = function({ articleList, propertyDef }) {\n    const props = {};\n\n    articleList.forEach(article => scrapProperties({ article, propertyDef, props }));\n\n    return Object.keys(props).map(key => props[key]);\n};\n\nexport const scrapProperties = function({ article, propertyDef, props: globalProps }) {\n    const props = globalProps || {};\n\n    propertyDef.forEach(propertyDef => {\n        if (article[propertyDef.name]) {\n            const prop = { type: propertyDef.name, name: article[propertyDef.name] };\n\n            collectProperty(props, prop);\n        }\n    });\n\n    if (article.properties) {\n        article.properties.forEach(prop => propertyDef.find(def => def.name === prop.name) && collectProperty(props, prop));\n    }\n\n    if (!globalProps) {\n        return Object.keys(props).map(key => props[key]);\n    }\n};\n\nconst collectProperty = function(props, prop) {\n    if (!props[prop.name]) {\n        props[prop.name] = prop;\n    } else if (props[prop.name] &&\n        props[prop.name].type !== prop.type &&\n        !props[`${prop.name}_${prop.type}`]) {\n        props[`${prop.name}_${prop.type}`] = prop;\n    }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./modules/ArticlePropertyScraper/index.js\n// module id = 23\n// module chunks = 0","// bootstrap.js\n\nimport App from './App';\n\nconst ready = function() {\n    App.init();\n};\n\nif (document.readyState === 'complete') {\n    ready();\n} else {\n    window.addEventListener('DOMContentLoaded', ready);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bootstrap.js\n// module id = 24\n// module chunks = 0","import Application from 'application-frame/core/Application';\n\nimport AssistantChatView from './views/AssistantChatView';\nimport FiltersView from './views/FiltersView';\nimport SearchBoxView from './views/SearchBoxView';\nimport SearchResultView from './views/SearchResultView';\n\n/**\n * [App description]\n *\n * @extends Application\n */\nconst App = {\n    name: 'Search Assistant Bot',\n    version: '1.0.0',\n\n    /**\n     * [init description]\n     *\n     * @return {void} [description]\n     */\n    init() {\n        this.constructor();\n\n        SearchResultView.init();\n        AssistantChatView.init();\n        SearchBoxView.init();\n        FiltersView.init();\n    },\n\n    __proto__: Application,\n};\n\nexport default App;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./App.js\n// module id = 25\n// module chunks = 0","import EventTarget from './EventTarget';\n\n/** @lends Application.prototype */\nlet Application = {\n\n    /**\n    * Name of this application so other components can identify the application.\n    *\n    * @type {string}\n    */\n    name : '',\n\n    /**\n    * Some components may need to know the version of this applicaion.\n    *\n    * @type {string}\n    */\n    version : '0.0.0',\n\n    /**\n    * @type {string}\n    */\n    author : '',\n\n    constructor() {\n        super.constructor();\n\n        return this;\n    },\n\n    _make(...args) {\n        return this.constructor(...args);\n    },\n\n    /**\n    * Initializes this application, default interface for components and modules.\n    *\n    * @return {void}\n    */\n    init : function(){\n        console.log(`Initialzing Application \"${this.name}\"!`);\n    },\n\n    /**\n    * This function will try to terminate the application by emitting the termination event.\n    *\n    * @param {string} reason - the reason for the termination.\n    *\n    * @return {void}\n    */\n    terminate : function(reason){\n        this.emit('terminate', reason);\n    },\n\n    __proto__: EventTarget,\n\n};\n\nexport default Application;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/application-frame/core/Application.js\n// module id = 26\n// module chunks = 0","const async = function(callback) {\n    return Promise.resolve().then(callback);\n};\n\nexport default async;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/application-frame/core/async.js\n// module id = 27\n// module chunks = 0","export const CurrentConfig = {\n    verboseLogging: false,\n};\n\nexport const enableVerboseLogging = function() {\n    CurrentConfig.verboseLogging = true;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/Config.js\n// module id = 28\n// module chunks = 0","import { Make } from '../af/util/make.js';\nimport Binding from './Binding.js';\nimport { parseExpression } from './Parser.js';\nimport { makeTemplate } from './Template.js';\n\nlet AutoBinding = Make(/** @lends module:DataBinding.AutoBinding.prototype*/{\n\n    scopeName : '',\n\n    /** @type {HTMLTemplateNode} */\n    template : null,\n\n    /** @type {boolean} */\n    _isBound : false,\n\n    /**\n     * An auto binding instanciates a template and binds it\n     * to a property of the current scope.\n     *\n     * @constructs\n     * @extends module:DataBinding.Binding\n     * @return {void}\n     */\n    _make : function(){},\n\n    /** @type module:DataBinding.ScopePrototype */\n    _scope : null,\n\n    update : function(scope) {\n        if (!this._isBound) {\n            let subScope = parseExpression(this.scopeName, scope);\n\n            setTimeout(() => {\n                let scopeHolder = null;\n                let scopeObjName = null;\n\n                if (this.scopeName.lastIndexOf('.') > 0) {\n                    scopeHolder = this.scopeName.split('.');\n                    scopeObjName =  scopeHolder.pop();\n                    scopeHolder = parseExpression(scopeHolder.join('.'), scope);\n\n                    scopeHolder[scopeObjName] = makeTemplate(this.template, subScope, true);\n\n                    this._scope = scopeHolder[scopeObjName];\n                } else {\n                    this._scope = makeTemplate(this.template, subScope, true);\n                }\n            }, 0);\n\n            this._isBound = true;\n        }\n    },\n\n    /**\n     * destroys this binding. This binding needs to be destroied before\n     * it is deleted, since it creates a new scope.\n     *\n     * @return {void}\n     */\n    destory : function(){\n        if (this._scope) {\n            return this._scope.__destroy__(true);\n        } else {\n            return [0, 0];\n        }\n    }\n\n}, Binding).get();\n\nexport default AutoBinding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/AutoBinding.js\n// module id = 29\n// module chunks = 0","import { Make } from '../af/util/make.js';\nimport { parseExpression } from './Parser.js';\nimport Binding from './Binding.js';\nimport { RenderEngine } from 'application-frame/rendering';\n\nlet ClassBinding = Make(/** @lends module:DataBinding.ClassBinding.prototype */{\n\n    /**\n     * @type {Object}\n     */\n    classes : null,\n\n    /**\n     * @type {Node}\n     */\n    parentNode : null,\n\n    /**\n     * @constructs\n     * @extends {module:DataBinding.Binding}\n     */\n    _make : Binding._make,\n\n    /**\n     * applies a class to the parent node, based on the binding values.\n     *\n     * @param  {module:DataBinding.ScopePrototype} scope the scope to operate on.\n     * @param  {Object} classes class-expression-map\n     * @param  {string} key     the class name to apply\n     *\n     * @return {void}\n     */\n    applyClass : function(scope, classes, key) {\n        let expression = classes[key];\n        let value = parseExpression(expression, scope);\n\n        key = (key[0] === '!') ? key.substr(1) : key;\n\n        if (value) {\n            this.parentNode.classList.add(key);\n        } else {\n            this.parentNode.classList.remove(key);\n        }\n    },\n\n    update : function(scope){\n        let classes = JSON.parse(JSON.stringify(this.classes));\n\n        Object.keys(classes)\n            .filter(key => key.indexOf('!') === 0)\n            .forEach(this.applyClass.bind(this, scope, classes));\n\n        let applyAssync = Object.keys(classes).filter(key => key.indexOf('!') !== 0);\n\n        if (applyAssync.length > 0) {\n            RenderEngine.scheduleRenderTask(() => {\n                applyAssync.forEach(this.applyClass.bind(this, scope, classes));\n            });\n        }\n    }\n\n}, Binding).get();\n\nexport default ClassBinding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/ClassBinding.js\n// module id = 30\n// module chunks = 0","import TaskList from './TaskList';\nimport { allocate } from '../memory';\n\nconst Frame = {\n    preRenderTasks: null,\n    renderTasks: null,\n    postRenderTasks: null,\n\n    get empty() {\n        return this.preRenderTasks.length === 0 &&\n            this.renderTasks.length === 0 &&\n            this.postRenderTasks.length === 0;\n    },\n\n    constructor() {\n        this.preRenderTasks = allocate('TaskList', TaskList); // Object.create(TaskList).constructor();\n        this.renderTasks = allocate('TaskList', TaskList); //Object.create(TaskList).constructor();\n        this.postRenderTasks = allocate('TaskList', TaskList); //Object.create(TaskList).constructor();\n\n        return this;\n    }\n};\n\nexport default Frame;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/application-frame/rendering/Frame.js\n// module id = 31\n// module chunks = 0","import CurrentFrameInterface from './CurrentFrameInterface';\nimport { allocate, release } from '../memory';\n\n/** @lends module:RenderEngine.TaskList.prototype */\nlet TaskList = {\n\n    /** @type Array */\n    tasks: null,\n\n    /** @type Array */\n    registeredIds: null,\n\n    /** @type {{ id: string, work: Function }} */\n    get last() {\n        return this.tasks[this.tasks.length - 1];\n    },\n\n    /** @type {number} */\n    get length() {\n        return this.tasks.length;\n    },\n\n    /**\n     * Render TaskList to manage rendertaks and optionally track duplicates by ids.\n     *\n     * @constructs\n     * @return {void}\n     */\n    constructor() {\n        this.tasks = allocate(0);\n        this.registeredIds = allocate(0);\n\n        return this;\n    },\n\n    /**\n     * adds a new item to the task list.\n     *\n     * @param  {Function} task the task to add to the list\n     * @param  {string|number|null} [id] the id of this tasks. If provided no task with the same id can be added again.\n     * @return {void}\n     */\n    push(task, id = null) {\n        if (!id || this.registeredIds.indexOf(id) < 0) {\n            this.tasks.push({ id: id, work: task });\n\n            if (id) {\n                this.registeredIds.push(id);\n            }\n        }\n    },\n\n    unshift(task, id = null) {\n        if (!id || this.registeredIds.indexOf(id) < 0) {\n            this.tasks.unshift({ id: id, work: task });\n\n            if (id) {\n                this.registeredIds.push(id);\n            }\n        }\n    },\n\n    flush() {\n        this.tasks = [];\n        this.registeredIds = [];\n    },\n\n    filter(callback) {\n        const newList = allocate(0);\n\n        for (let i = 0; i < this.length; i++) {\n            const item = this.tasks[i];\n\n            if (callback(item, i)) {\n                newList.push(item);\n            }\n        }\n\n        release(this.tasks);\n        this.tasks = newList;\n    },\n\n    run(...args) {\n        this.filter((task) => {\n            return task.work(...args) === CurrentFrameInterface.INTERUPT_CURRENT_TASK;\n        });\n    },\n\n    getAll() {\n        return this.tasks;\n    },\n};\n\nexport default TaskList;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/application-frame/rendering/TaskList.js\n// module id = 32\n// module chunks = 0","import { Make } from '../af/util/make.js';\nimport { parseExpression } from './Parser.js';\nimport { polyInvoke } from './Util.js';\nimport Binding from './Binding.js';\n\nlet EnabledBinding = Make(/** @lends module:DataBinding.EnabledBinding# */{\n    /**\n     * @type {Node}\n     */\n    parentNode : null,\n\n    /**\n     * @constructs\n     * @extends {module:DataBinding.Binding}\n     */\n    _make: Binding._make,\n\n    /**\n     * @param {module:DataBinding.ScopePrototype} scope the scope to work on\n     * @return {void}\n     */\n    update : function(scope){\n        let value = parseExpression(this.originalNodeValue, scope);\n\n        if (!value) {\n            polyInvoke(this.parentNode).setAttribute('disabled', '');\n        } else {\n            polyInvoke(this.parentNode).removeAttribute('disabled');\n        }\n    }\n\n}, Binding).get();\n\nexport default EnabledBinding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/EnabledBinding.js\n// module id = 33\n// module chunks = 0","/**\n * @module DataBinding/StyleBinding\n */\n\nimport { Make } from '../af/util/make';\nimport { ObjectParser, assignExpression } from './Parser';\n\nimport Binding from './Binding';\nimport { RenderEngine } from 'application-frame/rendering';\n\n/**\n * @param {StyleBinding} container - binding container\n * @param {ScopePrototype} scope - the scope for this binding\n * @return {void}\n */\nlet readStyleProperties = function(container, scope) {\n    Object.keys(container.bindings).forEach(styleKey => {\n        let style = window.getComputedStyle(container.parentNode);\n        let dimensions = container.parentNode.getBoundingClientRect();\n\n        if(styleKey.split('.')[0] === 'dimensions') {\n            let value = dimensions[styleKey.split('.')[1]];\n\n            assignExpression(container.bindings[styleKey], scope, value);\n        } else {\n            assignExpression(container.bindings[styleKey], scope, style[styleKey]);\n        }\n    });\n};\n\nlet StyleBinding = Make(/** @lends module:DataBinding/StyleBinding~StyleBinding# */{\n    bindings: null,\n\n    /**\n     * @constructs\n     * @extends {module:DataBinding.Binding}\n     *\n     * @return {void}\n     */\n    _make: function() {\n        this.bindings = ObjectParser(this.bindings);\n    },\n\n    update: function(scope) {\n        RenderEngine.schedulePostRenderTask(readStyleProperties.bind(null, this, scope));\n    }\n}, Binding).get();\n\n/**\n * @member StyleBinding\n * @type {module:DataBinding/StyleBinding~StyleBinding}\n * @static\n */\nexport default StyleBinding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/StyleBinding.js\n// module id = 34\n// module chunks = 0","import { Make } from '../af/util/make.js';\nimport { attributeNames } from './Mapping.js';\nimport { parseExpression, assignExpression } from './Parser.js';\nimport { polyInvoke } from './Util.js';\nimport Binding from './Binding.js';\n\n/**\n * @class TwoWayBinding\n * @extends module:DataBinding.Binding\n * @memberof module:DataBinding\n */\n\nlet TwoWayBinding = Make(/** @lends module:DataBinding.TwoWayBinding# */{\n    /**\n     * the last known view value\n     *\n     * @type {string}\n     */\n    currentValue : '',\n\n    /**\n     * @type {Node}\n     */\n    parentNode : null,\n\n    /**\n     * @type {boolean}\n     */\n    indirect : false,\n\n    /**\n     * @type {string}\n     */\n    viewBinding : '',\n\n    update : function(scope) {\n        // the current value on the scope\n        let value = parseExpression(this.properties[0], scope);\n\n        if (!this.indirect) {\n            let attribute = attributeNames.rename(this.node.name);\n\n            polyInvoke(this.parentNode).setAttribute(attribute, value);\n        } else {\n            // the current view value\n            //let viewValue = parseExpression(this.viewBinding, this.parentNode);\n\n            // check if our current scope value is different from the last value.\n            // Then check if the view value doesn't have unassigned changes.\n            // Only apply the scope value to the view if both rules apply.\n            if (value !== this.currentValue) {\n                assignExpression(this.viewBinding, this.parentNode, value);\n\n                if (parseExpression(this.viewBinding, this.parentNode) === value) {\n                    this.currentValue = value;\n                }\n\n                if (document.activeElement === this.parentNode) {\n                    let range = document.createRange();\n                    let selection = window.getSelection();\n\n                    range.selectNodeContents(this.parentNode);\n                    range.collapse(false);\n                    selection.removeAllRanges();\n                    selection.addRange(range);\n                }\n            }\n        }\n    }\n}, Binding).get();\n\nexport default TwoWayBinding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/TwoWayBinding.js\n// module id = 35\n// module chunks = 0","import { Make } from '../af/util/make.js';\nimport NetworkRequest from '../af/core/NetworkRequest';\n//import { polyInvoke } from './Util.js';\n\n\n/*let FakeTemplate = {\n    _markup : '',\n    _fragment: null,\n\n    _make : function(markup) {\n        this._markup = markup;\n    },\n\n    get content() {\n        if (!this._fragment) {\n            this._fragment = new DocumentFragment();\n            let container = document.createElement('div');\n\n            polyInvoke(container).innerHTML = this._markup;\n\n            [].forEach.apply(container.childNodes, [element => {\n                polyInvoke(this._fragment).appendChild(element);\n            }]);\n        }\n        return this._fragment;\n    }\n};*/\n\n/**\n * imports a template node from an external HTML file.\n *\n * @function\n *\n * @param {string} source the url of the file that holds the template to import\n * @param {HTMLTemplateElement} template the template element to contain the import\n *\n * @return {HTMLTemplateElement} returns the provided template node, but now holding the imported nodes.\n */\nexport let importTemplate = function(source, template) {\n    let request = Make(NetworkRequest)(source, {});\n\n    return request.send().then(markup => {\n        template.innerHTML = markup;\n\n        return template;\n    });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/TemplateLoader.js\n// module id = 36\n// module chunks = 0","/**\n * @module DataBinding/ViewPort\n */\n\nimport { DataBinding } from '../main';\nimport { Make } from '../af/util/make';\nimport { polyInvoke } from './Util';\nimport { RenderEngine } from 'application-frame/rendering';\n\nconst LIST_HAS_ITEMS = 0;\n\n/** @lends module:DataBinding/ViewPort.ViewPortInstance# */\nlet ViewPortInstance = {\n\n    /**\n     * @private\n     * @type {module:DataBinding.ScopePrototype}\n     */\n    _scope : null,\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _bound : false,\n\n    /**\n     * @private\n     * @type {module:DataBinding.ScopePrototype}\n     */\n    _innerScope : null,\n\n    /**\n     * @private\n     * @type {HTMLTemplateElement}\n     */\n    _originalTemplate : null,\n\n    /**\n     * @private\n     * @type {Application}\n     */\n    _application : null,\n\n    /**\n     * @constructs\n     *\n     * @param  {module:DataBinding.ScopePrototype} scope    the scope of this viewport instance\n     * @param  {Application} application the application this viewport instance belongs to\n     *\n     * @return {void}\n     */\n    _make : function(scope, application) {\n        this._scope = scope;\n        this._application = application;\n    },\n\n    /**\n     * binds the ViewPort to a scope so it can be filled with content\n     *\n     * @param  {Object} context a collection of properties to configure the viewport\n     *\n     * @return {Promise.<module:DataBinding/ViewPort.ViewPortInstance>}  promise for when the viewport is bound\n     */\n    bind : function(context) {\n        return new Promise((done, error) => {\n            if (!this._bound) {\n                RenderEngine.schedulePostRenderTask(() => {\n                    this._scope.templateUrl = context.template;\n                    this._scope.overflow = '';\n                    this._scope.__apply__();\n\n                    if (!this._originalTemplate) {\n                        this._originalTemplate = this._scope.element.firstElementChild;\n                    }\n\n                    this._innerScope = DataBinding.makeTemplate(\n                        this._originalTemplate,\n                        context.scope || {},\n                        this._application,\n                        this._scope\n                    );\n\n                    this._bound = true;\n\n                    context.scope = this._innerScope;\n\n                    done(this);\n                });\n            } else {\n                error('ViewPort: viewport is already bound!');\n            }\n        });\n    },\n\n    /**\n     * updates the inner scope of the viewport\n     *\n     * @param  {...*} args arguments to be passed on to {@link module:DataBinding.ScopePrototype#__apply__}\n     *\n     * @return {void}\n     */\n    update : function(...args) {\n        return this._innerScope.__apply__(...args);\n    },\n\n    /**\n     * the scope if ViewPort content\n     *\n     * @type {module:DataBinding.ScopePrototype}\n     */\n    get scope() {\n        return this._innerScope;\n    },\n\n    destory : function(){\n        if (this._bound) {\n            this._innerScope.__destroy__();\n\n            while (this._scope.element.children.length > LIST_HAS_ITEMS) {\n                polyInvoke(this._scope.element).removeChild(this._scope.element.firstChild);\n            }\n\n            polyInvoke(this._scope.element).appendChild(this._originalTemplate);\n            this._bound = false;\n            this._originalTemplate.processed = false;\n        }\n    },\n\n    /**\n     * enables the viewport content to overflow the viewports bounds\n     *\n     * @return {void}\n     */\n    alowOverflow : function() {\n        this._scope.overflow = 'overflow';\n        this._scope.__apply__();\n    },\n};\n\n/**\n * the interface for the ViewPort module\n *\n * @namespace\n * @static\n */\nlet ViewPort = {\n\n    /**\n     * all instanciated ViewPorts\n     *\n     * @private\n     * @type {Map.<module:DataBinding.ScopePrototype>}\n     */\n    _elements : new Map(),\n\n    /**\n     * the applicaion the viewports are registered to\n     *\n     * @private\n     * @type {Application}\n     */\n    _application : null,\n\n    /**\n     * @constructs\n     * @param {Application} application - the application this viewport belongs to.\n     * @return {void}\n     */\n    _make : function(application){\n        let style = polyInvoke(document.head).appendChild(document.createElement('style'));\n        let template = document.createElement('template');\n\n        polyInvoke(style).innerHTML = `\n            .view-port {\n                position: relative;\n                left: 0;\n                top: 0;\n                height: 100%;\n                width: 100%;\n                display: flex;\n                flex-direction: column;\n                overflow: auto;\n            }\n\n            .view-port.overflow {\n                overflow: visible;\n            }\n        `;\n\n        template.id = 'view-port';\n        polyInvoke(template).setAttribute('bind-element', '');\n        polyInvoke(template).setAttribute('component', '');\n\n        polyInvoke(template).innerHTML = `\n            <div class=\"custom-element {{overflow}}\">\n                <template src=\"templateUrl\" replace></template>\n            </div>\n        `;\n\n        application.on('newElement:view-port', (scope) => {\n            this._elements[scope.name] = Make(ViewPortInstance)(scope, application);\n            application.emit(`viewPort:ready:${scope.name}`);\n        });\n\n        this._application = application;\n\n        DataBinding.makeTemplate(template, () => { return {}; }, application);\n    },\n\n    /**\n     * fetches a viewPort instance by a name\n     *\n     * @param  {string} name the name to look for\n     *\n     * @return {Promise.<module:DataBinding.ScopePrototype>}  the matching scope\n     */\n    getInstance : function(name){\n        return new Promise((success) => {\n            if (this._elements[name]) {\n                success(this._elements[name]);\n            } else {\n                this._application.on(`viewPort:ready:${name}`, () => success(this._elements[name]));\n            }\n        });\n    },\n\n    /**\n     * destorys an viewPort instance\n     *\n     * @param  {module:DataBinding/ViewPort.ViewPortInstance} instance the instance to destroy\n     *\n     * @return {void}\n     */\n    free : function(instance){\n        this._elements[instance._scope.name] = null;\n\n        instance._scope.__destroy__();\n    }\n};\n\nexport default ViewPort;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/ViewPort.js\n// module id = 37\n// module chunks = 0","import { Make } from '../af/util/make.js';\nimport { parseExpression } from './Parser.js';\nimport Binding from './Binding.js';\nimport BindingRegistry from './BindingRegistry.js';\n\nlet IfBinding = Make(/** @lends module:DataBinding.IfBinding# **/{\n\n    /** @type {string} */\n    name: 'bind-if',\n\n    /**\n     * @type {Node}\n     */\n    parentNode: null,\n\n    /**\n     * @type {Node}\n     */\n    node: null,\n\n    /**\n     * @type {Node}\n     */\n    nextSibling: null,\n\n    /**\n     *\n     * @constructs\n     * @extends {Binding}\n     * @param {Node} parentNode - this node\n     * @param {string} text - the attribute value\n     * @param {ScopeInfo} scopeInfo - bindings container\n     *\n     * @return {void}\n     */\n    _make: function({ parentNode, text, scopeInfo }) {\n        this.node = parentNode;\n        this.parentNode = this.node.parentNode;\n        this.text = text;\n        this.nextSibling = parentNode.nextSibling;\n\n        scopeInfo.bindings.push(this);\n    },\n\n    update: function(scope) {\n        let isTrue = parseExpression(this.text, scope);\n\n        if (isTrue) {\n            if (this.node.parentNode !== this.parentNode) {\n                if (this.nextSibling) {\n                    this.parentNode.insertBefore(this.node, this.nextSibling);\n                } else {\n                    this.parentNode.appendChild(this.node);\n                }\n            }\n        } else {\n            if (this.node.parentNode === this.parentNode) {\n                this.parentNode.removeChild(this.node);\n            }\n        }\n    },\n\n}, Binding).get();\n\nBindingRegistry.register(IfBinding);\n\nexport default IfBinding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/IfBinding.js\n// module id = 38\n// module chunks = 0","import { Make } from '../af/util/make';\nimport { assignExpression, parseExpression } from './Parser';\nimport Binding from './Binding';\nimport BindingRegistry from './BindingRegistry.js';\n\nlet ElementToScopeBinding = Make(/** @lends module:DataBinding.ElementToScopeBinding.prototype */{\n\n    /**\n     * @type {string}\n     */\n    name: 'scope-id',\n\n    /**\n     * @type {Node}\n     */\n    parentNode: null,\n\n    /**\n     * @constructs\n     * @extends {module:DataBinding.Binding}\n     *\n     * @param  {Node} parentNode   parent node of this binding\n     * @param  {Object} scopeInfo  scope metadata object\n     * @param  {string} text       original text value of the binding\n     *\n     * @return {void}\n     */\n    _make: function({ parentNode, scopeInfo, text }) {\n        Binding._make.apply(this);\n\n        this.parentNode = parentNode;\n        this.text = text;\n\n        scopeInfo.bindings.push(this);\n\n    },\n\n    update: function(scope) {\n        /** @type {Node} */\n        let currentValue = parseExpression(this.text, scope);\n\n        if (currentValue !== this.parentNode) {\n            assignExpression(this.text, scope, this.parentNode);\n            scope.__apply__(null, true);\n        }\n    },\n\n}, Binding).get();\n\nBindingRegistry.register(ElementToScopeBinding);\n\nexport default ElementToScopeBinding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/ElementToScopeBinding.js\n// module id = 39\n// module chunks = 0","import Binding from './Binding.js';\nimport { parseExpression } from './Parser.js';\nimport { sanitizeText, polyInvoke } from './Util.js';\nimport BindingRegistry from './BindingRegistry.js';\n\n\n/**\n * [HtmlBinding description]\n *\n * @lends module:DataBinding.HtmlBinding#\n * @extends module:DataBinding.Binding\n *\n * @type {Object}\n */\nconst HtmlBinding = {\n\n    name: 'bind-html',\n\n\n    _make({ parentNode, text, scopeInfo }) {\n        this.parentNode = parentNode;\n        this.text = text;\n\n        scopeInfo.bindings.push(this);\n    },\n\n    update(scope) {\n        let text = parseExpression(this.text, scope, this.parentNode);\n\n        text = sanitizeText(text);\n\n        if (this.parentNode.innerHTML !== text) {\n            polyInvoke(this.parentNode).innerHTML = text;\n        }\n    },\n\n    __proto__: Binding,\n};\n\nBindingRegistry.register(HtmlBinding);\n\nexport default HtmlBinding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/HtmlBinding.js\n// module id = 40\n// module chunks = 0","import Binding from './Binding.js';\nimport { polyInvoke } from './Util.js';\nimport BindingRegistry from './BindingRegistry.js';\n\n\n/**\n * [CloakBinding description]\n *\n * @lends module:DataBinding.CloakBinding#\n * @extends module:DataBinding.Binding\n *\n * @type {Object}\n */\nconst CloakBinding = {\n\n    name: 'bind-cloak',\n\n    scopeBindingList: null,\n\n\n    _make({ parentNode, scopeInfo }) {\n        this.parentNode = parentNode;\n        this.scopeBindingList = scopeInfo.bindings;\n\n        scopeInfo.bindings.push(this);\n    },\n\n    update() {\n        polyInvoke(this.parentNode).removeAttribute(this.name);\n        this.scopeBindingList.splice(this.scopeBindingList.indexOf(this), 1);\n    },\n\n    __proto__: Binding,\n};\n\nlet style = document.createElement('style');\n\nstyle.id = 'cloak-binding';\n\nstyle.innerHTML = `\n    [bind-cloak] {\n        visibility: hidden;\n    }\n`;\n\ndocument.head.appendChild(style);\n\nBindingRegistry.register(CloakBinding);\n\nexport default CloakBinding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/CloakBinding.js\n// module id = 41\n// module chunks = 0","import BindingApi from '../BindingApi';\n\nconst AttributeBinding = {\n\n    name: 'bind-attr',\n\n    config: null,\n\n    currentValue: null,\n\n    constructor({ node: parentNode, text, parameter }) {\n        super._make(this);\n\n        this.parentNode = parentNode;\n\n        if (parameter && parameter != '') {\n            const [expression, eventName] = text.split('=');\n\n            this.config = {\n                isNewBinding: true,\n                expression: expression.trim(),\n                eventName: (eventName && eventName.trim()) || '',\n                attributeName: parameter,\n            };\n\n            if (eventName && eventName !== '') {\n                parentNode.addEventListener(eventName, this.onViewUpdate.bind(this));\n            }\n        } else {\n            this.config = BindingApi.parser.ObjectParser(text);\n        }\n\n        BindingApi(this).attachBinding(this);\n\n        return this;\n    },\n\n    _make(...args) {\n        return this.constructor(...args);\n    },\n\n    update(scope) {\n        if (this.config.isNewBinding) {\n            return this.updateNew(scope);\n        } else {\n            return this.updateOld(scope);\n        }\n    },\n\n    updateOld(scope) {\n        const { parser } = BindingApi(this);\n        const { parseExpression } = parser;\n        const attrName = this.config.name;\n        const attrValue = this.config.value ? parseExpression(this.config.value, scope) : '';\n        const attrEnabled = this.config.enabled ? parseExpression(this.config.enabled, scope) : true;\n\n\n        if (attrEnabled) {\n            this.parentNode.setAttribute(attrName, attrValue);\n        } else {\n            this.parentNode.removeAttribute(attrName);\n        }\n    },\n\n    updateNew(scope) {\n        const { parseExpression } = BindingApi(this).parser;\n        const value = parseExpression(this.config.expression, scope);\n\n        // check if our current scope value is different from the last value.\n        // Then check if the view value doesn't have unassigned changes.\n        // Only apply the scope value to the view if both rules apply.\n        if (value !== this.currentValue) {\n            this.setValue(value);\n\n            if (this.findValue() === value) {\n                this.currentValue = value;\n            }\n\n            if (document.activeElement === this.parentNode) {\n                const range = document.createRange();\n                const selection = window.getSelection();\n\n                range.selectNodeContents(this.parentNode);\n                range.collapse(false);\n                selection.removeAllRanges();\n                selection.addRange(range);\n            }\n        }\n    },\n\n    findValue() {\n        if (this.parentNode.hasOwnProperty(this.config.attributeName)) {\n            return this.parentNode[this.config.attributeName];\n        } else {\n            return this.parentNode.getAttribute(this.config.attributeName);\n        }\n    },\n\n    setValue(value) {\n        if (this.parentNode.hasOwnProperty(this.config.attributeName)) {\n            this.parentNode[this.config.attributeName] = value;\n        } else {\n            this.parentNode.setAttribute(this.config.attributeName, value);\n        }\n    },\n\n    onViewUpdate() {\n        const value = this.findValue();\n\n        if (this.currentValue !== value) {\n            BindingApi(this).scheduleScopeUpdate((scope) => {\n                BindingApi(this).parser.assignExpression(this.config.expression, scope);\n                this.currentValue = value;\n            });\n        }\n    },\n\n    __proto__: BindingApi().Binding,\n};\n\nBindingApi().registerBinding(AttributeBinding);\n\nexport default AttributeBinding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/bindings/AttributeBinding.js\n// module id = 42\n// module chunks = 0","import { Make } from '../../af/util/make.js';\nimport { bindNode } from '../Bind.js';\nimport BindingApi from '../BindingApi';\n\nconst { parseExpression } = BindingApi().parser;\n\n\nconst TemplateRepeatBinding = {\n\n    name: 'bind-repeat',\n\n    /**\n     * @type {WeakMap}\n     */\n    itemNodeList : null,\n\n    /**\n     * @type {WeakMap}\n     */\n    itemScopeList : null,\n\n    /**\n     * @type {Node}\n     */\n    template : null,\n\n    /**\n     * @type {Node}\n     */\n    marker : null,\n\n    /**\n     * @type {Array}\n     */\n    modelBackup : null,\n\n    model: null,\n\n    /**\n     * @type {Boolean}\n     */\n    fast: false,\n\n    /**\n     * @constructs\n     * @extends {Binding}\n     * @return {void}\n     */\n    _make({ node: template, text, parameter }) {\n        super._make();\n\n        const marker = document.createComment(`repeat ${template.id} with ${text}`);\n\n        if (template.nodeName !== 'TEMPLATE') {\n            console.error('[Repeat Binding] binding can only be used with template elements!');\n            return;\n        }\n\n        this.originalNodeValue = text;\n        this.template = template;\n        this.marker = marker;\n\n        if (parameter === 'fast') {\n            this.itemNodeList = [];\n            this.itemScopeList = [];\n            this.fast = true;\n        } else {\n            this.itemNodeList = new Map();\n            this.itemScopeList = new Map();\n        }\n\n        this.modelBackup = [];\n\n        console.log('replace template with marker');\n        template.parentNode.replaceChild(marker, template);\n\n        BindingApi(this).attachBinding(this);\n\n        return this;\n    },\n\n    /**\n     * renders one model item to the DOM\n     *\n     * @param  {ScopePrototype} scope      [description]\n     * @param  {string} itemName   [description]\n     * @param  {number} index      [description]\n     * @return {void}            [description]\n     */\n    renderItemFast(scope, itemName, index) {\n        let childScope = Make({\n            $first : index === 0,\n            $last : this.model.length-1 === index,\n            $index : index,\n            __parentScope__ : scope,\n        }, scope).get();\n\n        Object.defineProperty(childScope, itemName, {\n            get:() => {\n                return this.model[index];\n            }\n        });\n\n        const node = document.importNode(this.template.content, true).firstElementChild;\n        bindNode(node, childScope, true);\n\n        this.itemNodeList[index] = node;\n        this.itemScopeList[index] = childScope;\n\n        return node;\n    },\n\n    /**\n     * renders one model item to the DOM\n     *\n     * @param  {*} model      [description]\n     * @param  {ScopePrototype} scope      [description]\n     * @param  {string} itemName   [description]\n     * @param  {DocumentFragment} fragment   [description]\n     * @param  {Node} polyParent [description]\n     * @param  {Object} item       [description]\n     * @param  {number} index      [description]\n     * @return {void}            [description]\n     */\n    renderItemStable(model, scope, itemName, fragment, item, index) {\n        let node = null;\n\n        if (this.itemNodeList.has(item)) {\n            node = this.itemNodeList.get(item);\n            let childScope = this.itemScopeList.get(item);\n\n            childScope.$first = index === 0;\n            childScope.$last = model.length -1 === index;\n            childScope.$index = index;\n\n            childScope.update();\n        } else {\n            let childScope = Make({\n                $first : index === 0,\n                $last : model.length-1 === index,\n                $index : index,\n                __parentScope__ : scope,\n            }, scope).get();\n\n            childScope[itemName] = item;\n\n            node = document.importNode(this.template.content, true).firstElementChild;\n            bindNode(node, childScope, true);\n\n            this.itemNodeList.set(item, node);\n            this.itemScopeList.set(item, childScope);\n        }\n\n        fragment.appendChild(node);\n    },\n\n    updateFast(scope) {\n        const [itemName, link, expression] = this.originalNodeValue.split(' ');\n\n        this.model = parseExpression(expression, scope);\n\n        if (link !== 'in') {\n            console.console.error('DataBinding: invalide expression', this.originalNodeValue);\n            return;\n        }\n\n        if (!Array.isArray(this.model)) {\n            console.warn('A repeat binding can only consume arrays!', this.model);\n            this.model = [];\n        }\n\n        while (this.itemNodeList.length > this.model.length) {\n            const node = this.itemNodeList.pop();\n            const scope = this.itemScopeList.pop();\n\n            node.parentNode.removeChild(node);\n            scope.__destroy__();\n        }\n\n        this.itemScopeList.forEach(scope => scope.update());\n\n        while (this.itemNodeList.length < this.model.length) {\n            const marker = this.itemNodeList.length ? this.itemNodeList[this.itemNodeList.length-1] : this.marker;\n\n            const node = this.renderItemFast(scope, itemName, this.itemNodeList.length);\n\n            if (marker.nextElementSibling) {\n                marker.parentNode.insertBefore(node, marker.nextElementSibling);\n            } else {\n                marker.parentNode.appendChild(node);\n            }\n        }\n    },\n\n    updateStable(scope) {\n        let [itemName, link, expression] = this.originalNodeValue.split(' ');\n        let model = parseExpression(expression, scope);\n        let dirty = false;\n\n        if (link !== 'in') {\n            console.console.error('DataBinding: invalide expression', this.originalNodeValue);\n            return;\n        }\n\n        if (!Array.isArray(model)) {\n            console.warn('A repeat binding can only consume arrays!', model);\n            model = [];\n        }\n\n        dirty = this.modelBackup.length !== model.length;\n\n        if (!dirty) {\n            for (let i = 0; i < model.length; i++) {\n                if (model[i] !== this.modelBackup[i]) {\n                    dirty = true;\n                    break;\n                }\n            }\n        }\n\n        if (dirty) {\n            // clean out items that where removed.\n            this.modelBackup.forEach(item => {\n                if (model.indexOf(item) < 0) {\n                    const node = this.itemNodeList.get(item);\n\n                    // if the node doesn't exist something went totally wrong... but it happens :/\n                    if (node) {\n                        this.marker.parentNode.removeChild(node);\n                    }\n\n                    this.itemScopeList.delete(item);\n                    this.itemNodeList.delete(item);\n                }\n            });\n\n            this.modelBackup = model.slice();\n\n            if (window.Polymer) {\n                window.Polymer.dom.flush();\n            }\n\n            /** @type {DocumentFragment} */\n            const fragment = document.createDocumentFragment();\n\n            model.forEach(this.renderItemStable.bind(this, model, scope, itemName, fragment));\n\n            if (this.marker.nextElementSibling) {\n                this.marker.parentNode.insertBefore(fragment, this.marker.nextElementSibling);\n            } else {\n                this.marker.parentNode.appendChild(fragment);\n            }\n        }\n    },\n\n    update(scope) {\n        if (this.fast) {\n            return this.updateFast(scope);\n        } else {\n            return this.updateStable(scope);\n        }\n    },\n\n    destory() {\n        let count = this.modelBackup.reduce((prev, item) => {\n            let [scopes, bindings] = prev;\n            let scope = this.itemScopeList.get(item);\n            let [scopes_add, bindings_add] = scope.__destroy__(true);\n\n            return [scopes + scopes_add, bindings + bindings_add];\n        }, [0, 0]);\n\n        this.itemScopeList = null;\n        this.itemNodeList = null;\n\n        return count;\n    },\n\n    __proto__: BindingApi().Binding,\n};\n\nBindingApi().registerBinding(TemplateRepeatBinding);\n\nexport default TemplateRepeatBinding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/bindings/TemplateRepeatBinding.js\n// module id = 43\n// module chunks = 0","import BindingApi from '../BindingApi';\n\nconst EventBinding = {\n\n    name: 'bind-event',\n\n    constructor({ node, text, parameter }) {\n        super.constructor();\n\n        this.node = node;\n        this.text = text;\n        this.parameter = parameter;\n\n        BindingApi(this).scheduleScopeUpdate(this.registerEventHandler.bind(this));\n\n        return this;\n    },\n\n    _make(...args) {\n        this.constructor(...args);\n    },\n\n    registerEventHandler(scope) {\n        const handler = BindingApi(this).parser.parseExpression(this.text, scope);\n\n        this.node.addEventListener(this.parameter, (event) => {\n            let preventRecycle = false;\n\n            event.preventRecycle = () => preventRecycle = true;\n\n            handler(event, scope);\n\n            if (!preventRecycle) {\n                scope.update();\n            }\n        });\n    },\n\n    update() {\n        return true;\n    },\n\n    __proto__: BindingApi().Binding,\n};\n\nBindingApi().registerBinding(EventBinding);\n\nexport default EventBinding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/Jovan/search-bot/node_modules/@af-modules/databinding/lib/bindings/EventBinding.js\n// module id = 44\n// module chunks = 0","import { scrapProperties } from '../ArticlePropertyScraper';\nimport arrayContains from '../arrayContains';\n\nexport const suggestMostCommonPropType = function(articleList, propertyDef) {\n    const properties = articleList.reduce((list, article) => {\n        const props = scrapProperties({ article, propertyDef });\n\n        props.forEach(prop => {\n            if (!list[prop.type]) {\n                list[prop.type] = 1;\n            } else {\n                list[prop.type] += 1;\n            }\n        });\n\n        return list;\n    }, {});\n\n    const mostImportant = Object.keys(properties)\n        .sort((a, b) => properties[a] === properties[b] ? 0 : (properties[a] > properties[b] ? 1 : -1))\n        .shift();\n\n    const property = propertyDef.find(item => item.name === mostImportant);\n\n    return property;\n};\n\nexport const findArticlesWithProperties = function(articleList, properties, propertyDef) {\n    articleList.filter(article => {\n        const articleProperties = scrapProperties({ article, propertyDef });\n\n        arrayContains(articleProperties, properties);\n    });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./modules/PropertyAssistant/index.js\n// module id = 45\n// module chunks = 0","const arrayContains = function(array, subset) {\n    const result = array.some(item => {\n        const subIndex = subset.findIndex(subItem => match(item, subItem));\n\n        if (subIndex > -1) {\n            subIndex.splice(subIndex, 1);\n        }\n\n        if (subset.length === 0) {\n            return true;\n        }\n    });\n\n    return result;\n};\n\nexport default arrayContains;\n\nconst match = function(objectA, objectB) {\n    const keys = (Object.keys(objectA).length > Object.keys(objectB).length) ?\n        Object.keys(objectA) : Object.keys(objectB);\n\n    return keys.reduce((state, key) => state && objectA[key] === objectB[key]);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./modules/arrayContains.js\n// module id = 46\n// module chunks = 0","//import DataStorage from 'application-frame/core/DataStorage';\nimport ViewController from '@af-modules/databinding/prototypes/ViewController';\nimport { SelectedProperties } from '../SelectedProperties';\n\n//const { create } = Object;\n\nconst FiltersView = {\n\n    template: 'filters',\n\n    selectedProperties: null,\n\n    selectedPropertiesList: [],\n\n    init() {\n        this.constructor();\n        this.selectedProperties = SelectedProperties;\n        this.selectedProperties.when(properties => {\n            this.selectedPropertiesList = Object.keys(properties)\n                .map(key => ({ name: key, values: properties[key]}));\n\n            this.scope.update();\n        });\n    },\n\n    notLast(list, index) {\n        return !(list.length-1 === index);\n    },\n\n    __proto__: ViewController,\n};\n\nexport default FiltersView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./views/FiltersView.js\n// module id = 47\n// module chunks = 0","import '../modules/ArrayAll';\n\nimport NetworkRequest from 'application-frame/core/NetworkRequest';\nimport ViewController from '@af-modules/databinding/prototypes/ViewController';\n\nimport { SelectedProperties } from '../SelectedProperties';\nimport { configureGrammar, parseSearchQuery } from '../modules/SearchParser';\nimport ActionChain from '../ActionChain';\nimport AssistantChatView from './AssistantChatView';\n\nconst { create } = Object;\n\nconst SearchBoxView = {\n\n    template: 'search-box',\n\n    searchResults: null,\n\n    init() {\n        this.constructor();\n        this.createOnSearchChain();\n\n        [create(NetworkRequest).constructor('./data/propertyTypes.json', {type: 'json'}),\n            create(NetworkRequest).constructor('./data/propertyValues.json', {type: 'json'})]\n        .map(request => request.send())\n            .all(promises => Promise.all(promises))\n            .then(([types, values]) => {\n                configureGrammar({\n                    fillWords: ['as', 'with', 'like', 'a'],\n                    types,\n                    values,\n                });\n            });\n    },\n\n    selectedProperties: SelectedProperties,\n    onSearchChain: null,\n\n    createOnSearchChain() {\n        this.onSearchChain = ActionChain().stage(event => {\n            return new Promise((resolve) => setTimeout(() => resolve(event), 100));\n        }).stage(event => {\n            const searchText = event.target.value;\n            const result = parseSearchQuery(searchText);\n\n            const selected = result.reduce((map, item) => {\n                if (!map[item.type]) {\n                    map[item.type] = [];\n                }\n\n                map[item.type].push(item['name']);\n\n                return map;\n            }, {});\n\n            this.selectedProperties.fill(selected);\n        }).stage(() => {\n            return new Promise(r => setTimeout(r, 100));\n        }).stage(() => {\n            AssistantChatView.startSession();\n        });\n    },\n\n    onSearch(event) {\n        this.onSearchChain.feed(event);\n    },\n\n    __proto__: ViewController,\n};\n\nexport default SearchBoxView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./views/SearchBoxView.js\n// module id = 48\n// module chunks = 0","Array.prototype.all = function(callback) {\n    return callback(this);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./modules/ArrayAll.js\n// module id = 49\n// module chunks = 0","\nconst config = {\n    fillWords: null,\n    types: null,\n    values: null,\n};\n\nexport const parseSearchQuery = function(queryText) {\n\n    if (!config.fillWords || !config.types || !config.values) {\n        return [];\n    }\n\n    const query = queryText.split(' ').filter(word => !config.fillWords.includes(word));\n\n    const containedValues = query.map(word => (word in config.values) ? config.values[word] : null)\n        .reduce((list, item) => list.concat(item), [])\n        .filter((value, index, list) => !!value && list.indexOf(value) === index)\n        .filter((value) => queryText.search(value.regex) > -1);\n\n    return containedValues;\n};\n\nexport const configureGrammar = function({ fillWords = [], types = [], values = [] } = {}) {\n\n    config.fillWords = fillWords;\n    config.types = types;\n    config.values = values.reduce((container, value) => {\n        let names = [];\n\n        names = names.concat(value.name.split(' ').map(item => item.toLowerCase()));\n\n        if (value.aliases) {\n            names = names.concat(value.aliases.map(alias => alias.split(' '))\n                .reduce((list, item) => list.concat(item), []));\n\n            value.regex = new RegExp(`(${value.name.toLowerCase()}|${value.aliases.map(item => item.toLowerCase()).join('|')})`);\n        } else {\n            value.regex = new RegExp(`${value.name.toLowerCase()}`);\n        }\n\n        names.forEach(name => {\n            if (!container[name]) {\n                container[name] = [];\n            }\n\n            container[name].push(value);\n        });\n\n        return container;\n    }, {});\n\n    return config;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./modules/SearchParser/index.js\n// module id = 50\n// module chunks = 0","const { create } = Object;\n\nconst ActionChain = {\n    _stages: null,\n    _current: null,\n    _coreId: null,\n    _currentId: null,\n\n    stage(callback) {\n        this._stages.push(callback);\n\n        return this;\n    },\n\n    feed(event) {\n        const instance = create(this);\n\n        this._coreId = window.performance.now();\n        instance._currentId = this._coreId;\n        instance._current = 0;\n\n        instance._runStage(event);\n    },\n\n    _scheduleStage(currentValue) {\n        if (currentValue && currentValue.then && typeof currentValue.then === 'function') {\n            currentValue.then(this._runStage.bind(this));\n        } else {\n            Promise.resolve(currentValue).then(this._runStage.bind(this));\n        }\n\n        console.log(`stage ${this._current} has been scheduled!`);\n    },\n\n    _runStage(currentValue) {\n        if (this._currentId !== this._coreId) {\n            console.log(`${this._currentId} has been canceled by ${this._coreId}`);\n            return;\n        }\n\n        const callback = this._stages[this._current];\n        const newValue = callback(currentValue);\n\n        this._current += 1;\n\n        if (this._current === this._stages.length) {\n            console.log('ActionChain completed', this);\n            return;\n        }\n\n        this._scheduleStage(newValue);\n    }\n};\n\nconst craft = function() {\n    const chain = create(ActionChain);\n\n    chain._stages = [];\n    chain.feed = chain.feed.bind(chain);\n\n    return chain;\n};\n\nexport default craft;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./ActionChain.js\n// module id = 51\n// module chunks = 0","//import DataStorage from 'application-frame/core/DataStorage';\nimport ViewController from '@af-modules/databinding/prototypes/ViewController';\nimport { ArticleStore } from '../ArticleStore';\n\n//const { create } = Object;\n\nconst SearchResultView = {\n\n    template: 'search-results',\n\n    searchResults: null,\n\n    init() {\n        this.constructor();\n        this.searchResults = ArticleStore;\n        this.searchResults.when(this.scope.update.bind(this.scope));\n    },\n\n    __proto__: ViewController,\n};\n\nexport default SearchResultView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./views/SearchResultView.js\n// module id = 52\n// module chunks = 0"],"sourceRoot":""}